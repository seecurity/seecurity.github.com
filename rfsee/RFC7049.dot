digraph Flow {
  rankdir=LR;
  splines=true;
  concentrate=true;   // merge parallel edges / reduce clutter
  nodesep=0.25;       // horizontal/vertical separation between nodes
  ranksep=0.35;       // separation between ranks (columns in LR)
  RFC7049 [label="RFC7049
Concise Binary Object Representation
(CBOR)
2013", shape=ellipse, fillcolor="#e8f0ff", tooltip="The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation.  These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.", style=filled, fillcolor=green]; 

  obs_by [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  obs_by -> RFC7049;
  RFC8949 [label="RFC8949
Concise Binary Object Representation
(CBOR)
2020", shape=ellipse, URL="RFC8949.html", target="_top", tooltip="The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack. This document obsoletes RFC 7049, providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049. It does not create a new version of the format."];
  RFC8949 -> obs_by;

  obs [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  RFC7049 -> obs;

  updates [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  RFC7049 -> updates;

  updated_by [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  updated_by -> RFC7049;

  cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  RFC7049 -> cites;
  RFC4627 [label="RFC4627
The application/json Media Type for
JavaScript Object Notation (JSON)
2006", shape=ellipse, URL="RFC4627.html", target="_top", tooltip="JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.  This memo provides information for the Internet community."];
  cites -> RFC4627;
  RFC2119 [label="RFC2119
Key words for use in RFCs to Indicate
Requirement Levels
1997", shape=ellipse, URL="RFC2119.html", target="_top", tooltip="In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements."];
  cites -> RFC2119;
  RFC3629 [label="RFC3629
UTF-8, a transformation format of ISO
10646
2003", shape=ellipse, URL="RFC3629.html", target="_top", tooltip="ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279."];
  cites -> RFC3629;
  RFC3339 [label="RFC3339
Date and Time on the Internet:
Timestamps
2002", shape=ellipse, URL="RFC3339.html", target="_top", tooltip="This document defines a date and time format for use in Internet protocols that is a profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."];
  cites -> RFC3339;
  RFC4287 [label="RFC4287
The Atom Syndication Format
2005", shape=ellipse, URL="RFC4287.html", target="_top", tooltip="This document specifies Atom, an XML-based Web content and metadata syndication format. [STANDARDS-TRACK]"];
  cites -> RFC4287;
  RFC4648 [label="RFC4648
The Base16, Base32, and Base64 Data
Encodings
2006", shape=ellipse, URL="RFC4648.html", target="_top", tooltip="This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. [STANDARDS-TRACK]"];
  cites -> RFC4648;
  RFC3986 [label="RFC3986
Uniform Resource Identifier (URI):
Generic Syntax
2005", shape=ellipse, URL="RFC3986.html", target="_top", tooltip="A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme. [STANDARDS-TRACK]"];
  cites -> RFC3986;
  RFC2045 [label="RFC2045
Multipurpose Internet Mail Extensions
(MIME) Part One: Format of Internet
Message Bodies
1996", shape=ellipse, URL="RFC2045.html", target="_top", tooltip="This initial document specifies the various headers used to describe the structure of MIME messages. [STANDARDS-TRACK]"];
  cites -> RFC2045;
  RFC5226 [label="RFC5226
Guidelines for Writing an IANA
Considerations Section in RFCs
2008", shape=ellipse, URL="RFC5226.html", target="_top", tooltip="Many protocols make use of identifiers consisting of constants and other well-known values. Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec). To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority. For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA). In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made. If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role. This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA. This document obsoletes RFC 2434. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements."];
  cites -> RFC5226;
  RFC6838 [label="RFC6838
Media Type Specifications and
Registration Procedures
2013", shape=ellipse, URL="RFC6838.html", target="_top", tooltip="This document defines procedures for the specification and registration of media types for use in HTTP, MIME, and other Internet protocols.  This memo documents an Internet Best Current Practice."];
  cites -> RFC6838;

  rev_cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  rev_cites -> RFC7049;
  RFC8075 [label="RFC8075
Guidelines for Mapping Implementations:
HTTP to the Constrained Application
Protocol (CoAP)
2017", shape=ellipse, URL="RFC8075.html", target="_top", tooltip="This document provides reference information for implementing a cross-protocol network proxy that performs translation from the HTTP protocol to the Constrained Application Protocol (CoAP).  This will enable an HTTP client to access resources on a CoAP server through the proxy.  This document describes how an HTTP request is mapped to a CoAP request and how a CoAP response is mapped back to an HTTP response.  This includes guidelines for status code, URI, and media type mappings, as well as additional interworking advice."];
  RFC8075 -> rev_cites;
  RFC8152 [label="RFC8152
CBOR Object Signing and Encryption
(COSE)
2017", shape=ellipse, URL="RFC8152.html", target="_top", tooltip="Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size.  There is a need for the ability to have basic security services defined for this data format.  This document defines the CBOR Object Signing and Encryption (COSE) protocol.  This specification describes how to create and process signatures, message authentication codes, and encryption using CBOR for serialization.  This specification additionally describes how to represent cryptographic keys using CBOR."];
  RFC8152 -> rev_cites;
  RFC8230 [label="RFC8230
Using RSA Algorithms with CBOR Object
Signing and Encryption (COSE) Messages
2017", shape=ellipse, URL="RFC8230.html", target="_top", tooltip="The CBOR Object Signing and Encryption (COSE) specification defines cryptographic message encodings using Concise Binary Object Representation (CBOR).  This specification defines algorithm encodings and representations enabling RSA algorithms to be used for COSE messages.  Encodings are specified for the use of RSA Probabilistic Signature Scheme (RSASSA-PSS) signatures, RSA Encryption Scheme - Optimal Asymmetric Encryption Padding (RSAES-OAEP) encryption, and RSA keys."];
  RFC8230 -> rev_cites;
  RFC8392 [label="RFC8392
CBOR Web Token (CWT)
2018", shape=ellipse, URL="RFC8392.html", target="_top", tooltip="CBOR Web Token (CWT) is a compact means of representing claims to be transferred between two parties.  The claims in a CWT are encoded in the Concise Binary Object Representation (CBOR), and CBOR Object Signing and Encryption (COSE) is used for added application-layer security protection.  A claim is a piece of information asserted about a subject and is represented as a name/value pair consisting of a claim name and a claim value.  CWT is derived from JSON Web Token (JWT) but uses CBOR rather than JSON."];
  RFC8392 -> rev_cites;
  RFC8428 [label="RFC8428
Sensor Measurement Lists (SenML)
2018", shape=ellipse, URL="RFC8428.html", target="_top", tooltip="This specification defines a format for representing simple sensor measurements and device parameters in Sensor Measurement Lists (SenML).  Representations are defined in JavaScript Object Notation (JSON), Concise Binary Object Representation (CBOR), Extensible Markup Language (XML), and Efficient XML Interchange (EXI), which share the common SenML data model.  A simple sensor, such as a temperature sensor, could use one of these media types in protocols such as HTTP or the Constrained Application Protocol (CoAP) to transport the measurements of the sensor or to be configured."];
  RFC8428 -> rev_cites;
  RFC8576 [label="RFC8576
Internet of Things (IoT) Security: State
of the Art and Challenges
2019", shape=ellipse, URL="RFC8576.html", target="_top", tooltip="The Internet of Things (IoT) concept refers to the usage of standard Internet protocols to allow for human-to-thing and thing-to-thing communication. The security needs for IoT systems are well recognized, and many standardization steps to provide security have been taken -- for example, the specification of the Constrained Application Protocol (CoAP) secured with Datagram Transport Layer Security (DTLS). However, security challenges still exist, not only because there are some use cases that lack a suitable solution, but also because many IoT devices and systems have been designed and deployed with very limited security capabilities. In this document, we first discuss the various stages in the lifecycle of a thing. Next, we document the security threats to a thing and the challenges that one might face to protect against these threats. Lastly, we discuss the next steps needed to facilitate the deployment of secure IoT systems. This document can be used by implementers and authors of IoT specifications as a reference for details about security considerations while documenting their specific security challenges, threat models, and mitigations. This document is a product of the IRTF Thing-to-Thing Research Group (T2TRG)."];
  RFC8576 -> rev_cites;
  RFC8610 [label="RFC8610
Concise Data Definition Language (CDDL):
A Notational Convention to Express
Concise Binary Object Representation
(CBOR) and JSON Data Structures
2019", shape=ellipse, URL="RFC8610.html", target="_top", tooltip="This document proposes a notational convention to express Concise Binary Object Representation (CBOR) data structures (RFC 7049).  Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON."];
  RFC8610 -> rev_cites;
  RFC8613 [label="RFC8613
Object Security for Constrained RESTful
Environments (OSCORE)
2019", shape=ellipse, URL="RFC8613.html", target="_top", tooltip="This document defines Object Security for Constrained RESTful Environments (OSCORE), a method for application-layer protection of the Constrained Application Protocol (CoAP), using CBOR Object Signing and Encryption (COSE). OSCORE provides end-to-end protection between endpoints communicating using CoAP or CoAP-mappable HTTP. OSCORE is designed for constrained nodes and networks supporting a range of proxy operations, including translation between different transport protocols. Although an optional functionality of CoAP, OSCORE alters CoAP options processing and IANA registration. Therefore, this document updates RFC 7252."];
  RFC8613 -> rev_cites;
  RFC8618 [label="RFC8618
Compacted-DNS (C-DNS): A Format for DNS
Packet Capture
2019", shape=ellipse, URL="RFC8618.html", target="_top", tooltip="This document describes a data representation for collections of DNS messages.  The format is designed for efficient storage and transmission of large packet captures of DNS traffic; it attempts to minimize the size of such packet capture files but retain the full DNS message contents along with the most useful transport metadata.  It is intended to assist with the development of DNS traffic- monitoring applications."];
  RFC8618 -> rev_cites;
  RFC8639 [label="RFC8639
Subscription to YANG Notifications
2019", shape=ellipse, URL="RFC8639.html", target="_top", tooltip="This document defines a YANG data model and associated mechanisms enabling subscriber-specific subscriptions to a publisher's event streams.  Applying these elements allows a subscriber to request and receive a continuous, customized feed of publisher-generated information."];
  RFC8639 -> rev_cites;
  RFC8710 [label="RFC8710
Multipart Content-Format for the
Constrained Application Protocol (CoAP)
2020", shape=ellipse, URL="RFC8710.html", target="_top", tooltip="This memo defines application/multipart-core, an application-independent media type that can be used to combine representations of zero or more different media types (each with a Constrained Application Protocol (CoAP) Content-Format identifier) into a single representation, with minimal framing overhead."];
  RFC8710 -> rev_cites;
  RFC8727 [label="RFC8727
JSON Binding of the Incident Object
Description Exchange Format
2020", shape=ellipse, URL="RFC8727.html", target="_top", tooltip="The Incident Object Description Exchange Format (IODEF) defined in RFC 7970 provides an information model and a corresponding XML data model for exchanging incident and indicator information.  This document gives implementers and operators an alternative format to exchange the same information by defining an alternative data model implementation in JSON and its encoding in Concise Binary Object Representation (CBOR)."];
  RFC8727 -> rev_cites;
  RFC8742 [label="RFC8742
Concise Binary Object Representation
(CBOR) Sequences
2020", shape=ellipse, URL="RFC8742.html", target="_top", tooltip="This document describes the Concise Binary Object Representation (CBOR) Sequence format and associated media type application/cbor-seq. A CBOR Sequence consists of any number of encoded CBOR data items, simply concatenated in sequence. Structured syntax suffixes for media types allow other media types to build on them and make it explicit that they are built on an existing media type as their foundation. This specification defines and registers +cbor-seq as a structured syntax suffix for CBOR Sequences."];
  RFC8742 -> rev_cites;
  RFC8746 [label="RFC8746
Concise Binary Object Representation
(CBOR) Tags for Typed Arrays
2020", shape=ellipse, URL="RFC8746.html", target="_top", tooltip="The Concise Binary Object Representation (CBOR), as defined in RFC 7049, is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. This document makes use of this extensibility to define a number of CBOR tags for typed arrays of numeric data, as well as additional tags for multi-dimensional and homogeneous arrays. It is intended as the reference document for the IANA registration of the CBOR tags defined."];
  RFC8746 -> rev_cites;
  RFC8747 [label="RFC8747
Proof-of-Possession Key Semantics for
CBOR Web Tokens (CWTs)
2020", shape=ellipse, URL="RFC8747.html", target="_top", tooltip="This specification describes how to declare in a CBOR Web Token (CWT) (which is defined by RFC 8392) that the presenter of the CWT possesses a particular proof-of-possession key.  Being able to prove possession of a key is also sometimes described as being the holder-of-key.  This specification provides equivalent functionality to Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs) (RFC 7800) but using Concise Binary Object Representation (CBOR) and CWTs rather than JavaScript Object Notation (JSON) and JSON Web Tokens (JWTs)."];
  RFC8747 -> rev_cites;
  RFC8782 [label="RFC8782
Distributed Denial-of-Service Open
Threat Signaling (DOTS) Signal Channel
Specification
2020", shape=ellipse, URL="RFC8782.html", target="_top", tooltip="This document specifies the Distributed Denial-of-Service Open Threat Signaling (DOTS) signal channel, a protocol for signaling the need for protection against Distributed Denial-of-Service (DDoS) attacks to a server capable of enabling network traffic mitigation on behalf of the requesting client. A companion document defines the DOTS data channel, a separate reliable communication layer for DOTS management and configuration purposes."];
  RFC8782 -> rev_cites;
  RFC8790 [label="RFC8790
FETCH and PATCH with Sensor Measurement
Lists (SenML)
2020", shape=ellipse, URL="RFC8790.html", target="_top", tooltip="The Sensor Measurement Lists (SenML) media type and data model can be used to send collections of resources, such as batches of sensor data or configuration parameters.  The Constrained Application Protocol (CoAP) FETCH, PATCH, and iPATCH methods enable accessing and updating parts of a resource or multiple resources with one request.  This document defines new media types for the CoAP FETCH, PATCH, and iPATCH methods for resources represented using the SenML data model."];
  RFC8790 -> rev_cites;
  RFC8801 [label="RFC8801
Discovering Provisioning Domain Names
and Data
2020", shape=ellipse, URL="RFC8801.html", target="_top", tooltip="Provisioning Domains (PvDs) are defined as consistent sets of network configuration information. PvDs allows hosts to manage connections to multiple networks and interfaces simultaneously, such as when a home router provides connectivity through both a broadband and cellular network provider. This document defines a mechanism for explicitly identifying PvDs through a Router Advertisement (RA) option. This RA option announces a PvD identifier, which hosts can compare to differentiate between PvDs. The option can directly carry some information about a PvD and can optionally point to PvD Additional Information that can be retrieved using HTTP over TLS."];
  RFC8801 -> rev_cites;
  RFC8921 [label="RFC8921
Dynamic Service Negotiation: The
Connectivity Provisioning Negotiation
Protocol (CPNP)
2020", shape=ellipse, URL="RFC8921.html", target="_top", tooltip="This document defines the Connectivity Provisioning Negotiation Protocol (CPNP), which is designed to facilitate the dynamic negotiation of service parameters. CPNP is a generic protocol that can be used for various negotiation purposes that include (but are not necessarily limited to) connectivity provisioning services, storage facilities, Content Delivery Networks, etc."];
  RFC8921 -> rev_cites;
  RFC8943 [label="RFC8943
Concise Binary Object Representation
(CBOR) Tags for Date
2020", shape=ellipse, URL="RFC8943.html", target="_top", tooltip="The Concise Binary Object Representation (CBOR), as specified in RFC 7049, is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. In CBOR, one point of extensibility is the definition of CBOR tags. RFC 7049 defines two tags for time: CBOR tag 0 (date/time string as per RFC 3339) and tag 1 (POSIX seconds since the epoch). Since then, additional requirements have become known. This specification defines a CBOR tag for a date text string (as per RFC 3339) for applications needing a textual date representation within the Gregorian calendar without a time. It also defines a CBOR tag for days since the date 1970-01-01 in the Gregorian calendar for applications needing a numeric date representation without a time. This specification is the reference document for IANA registration of the CBOR tags defined."];
  RFC8943 -> rev_cites;
  RFC8949 [label="RFC8949
Concise Binary Object Representation
(CBOR)
2020", shape=ellipse, URL="RFC8949.html", target="_top", tooltip="The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack. This document obsoletes RFC 7049, providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049. It does not create a new version of the format."];
  RFC8949 -> rev_cites;
}
