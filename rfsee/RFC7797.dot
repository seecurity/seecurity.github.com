digraph Flow {
  rankdir=LR;
  splines=true;
  concentrate=true;   // merge parallel edges / reduce clutter
  nodesep=0.25;       // horizontal/vertical separation between nodes
  ranksep=0.35;       // separation between ranks (columns in LR)
  RFC7797 [label="RFC7797
JSON Web Signature (JWS) Unencoded
Payload Option
2016", shape=ellipse, fillcolor="#e8f0ff", tooltip="JSON Web Signature (JWS) represents the payload of a JWS as a base64url-encoded value and uses this value in the JWS Signature computation. While this enables arbitrary payloads to be integrity protected, some have described use cases in which the base64url encoding is unnecessary and/or an impediment to adoption, especially when the payload is large and/or detached. This specification defines a means of accommodating these use cases by defining an option to change the JWS Signing Input computation to not base64url- encode the payload. This option is intended to broaden the set of use cases for which the use of JWS is a good fit. This specification updates RFC 7519 by stating that JSON Web Tokens (JWTs) MUST NOT use the unencoded payload option defined by this specification."]; 

  obs_by [label="obsoletes", shape=box];
  obs_by -> RFC7797;

  obs [label="obsoletes", shape=box];
  RFC7797 -> obs;

  updates [label="updates", shape=box];
  RFC7797 -> updates;
  RFC7519 [label="RFC7519
JSON Web Token (JWT)
2015", shape=ellipse, URL="RFC7519.html", target="_top", tooltip="JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties.  The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted."];
  updates -> RFC7519;

  updated_by [label="updates", shape=box];
  updated_by -> RFC7797;

  cites [label="cites", shape=box];
  RFC7797 -> cites;
  RFC2119 [label="RFC2119
Key words for use in RFCs to Indicate
Requirement Levels
1997", shape=ellipse, URL="RFC2119.html", target="_top", tooltip="In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements."];
  cites -> RFC2119;
  RFC3629 [label="RFC3629
UTF-8, a transformation format of ISO
10646
2003", shape=ellipse, URL="RFC3629.html", target="_top", tooltip="ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279."];
  cites -> RFC3629;
  RFC3986 [label="RFC3986
Uniform Resource Identifier (URI):
Generic Syntax
2005", shape=ellipse, URL="RFC3986.html", target="_top", tooltip="A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme. [STANDARDS-TRACK]"];
  cites -> RFC3986;
  RFC7159 [label="RFC7159
The JavaScript Object Notation (JSON)
Data Interchange Format
2014", shape=ellipse, URL="RFC7159.html", target="_top", tooltip="JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format. It was derived from the ECMAScript Programming Language Standard. JSON defines a small set of formatting rules for the portable representation of structured data. This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance."];
  cites -> RFC7159;

  rev_cites [label="cites", shape=box];
  rev_cites -> RFC7797;
  RFC8322 [label="RFC8322
Resource-Oriented Lightweight
Information Exchange (ROLIE)
2018", shape=ellipse, URL="RFC8322.html", target="_top", tooltip="This document defines a resource-oriented approach for security automation information publication, discovery, and sharing.  Using this approach, producers may publish, share, and exchange representations of software descriptors, security incidents, attack indicators, software vulnerabilities, configuration checklists, and other security automation information as web-addressable resources.  Furthermore, consumers and other stakeholders may access and search this security information as needed, establishing a rapid and on-demand information exchange network for restricted internal use or public access repositories.  This specification extends the Atom Publishing Protocol and Atom Syndication Format to transport and share security automation resource representations."];
  RFC8322 -> rev_cites;
  RFC8555 [label="RFC8555
Automatic Certificate Management
Environment (ACME)
2019", shape=ellipse, URL="RFC8555.html", target="_top", tooltip="Public Key Infrastructure using X.509 (PKIX) certificates are used for a number of purposes, the most significant of which is the authentication of domain names.  Thus, certification authorities (CAs) in the Web PKI are trusted to verify that an applicant for a certificate legitimately represents the domain name(s) in the certificate.  As of this writing, this verification is done through a collection of ad hoc mechanisms.  This document describes a protocol that a CA and an applicant can use to automate the process of verification and certificate issuance.  The protocol also provides facilities for other certificate management functions, such as certificate revocation."];
  RFC8555 -> rev_cites;
}
