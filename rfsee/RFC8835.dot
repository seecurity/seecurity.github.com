digraph Flow {
  layout=twopi;
  root=RFC8835;
  overlap=false;
  RFC8835 [label="RFC8835
Transports for WebRTC
2021", shape=ellipse, fillcolor="#e8f0ff", tooltip="This document describes the data transport protocols used by Web Real-Time Communication (WebRTC), including the protocols used for interaction with intermediate boxes such as firewalls, relays, and NAT boxes.", style=filled, fillcolor=green, fontsize=18, penwidth=3, fontweight=bold]; 

  obs_by [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  obs_by -> RFC8835;

  obs [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  RFC8835 -> obs;

  updates [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  RFC8835 -> updates;

  updated_by [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  updated_by -> RFC8835;

  cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  RFC8835 -> cites;
  RFC8825 [label="RFC8825
Overview: Real-Time Protocols for
Browser-Based Applications
2021", shape=ellipse, URL="RFC8825.html", target="_top", tooltip="This document gives an overview and context of a protocol suite intended for use with real-time applications that can be deployed in browsers -- real-time communication on the Web. It intends to serve as a starting and coordination point to make sure that (1) all the parts that are needed to achieve this goal are findable and (2) the parts that belong in the Internet protocol suite are fully specified and on the right publication track. This document is an applicability statement -- it does not itself specify any protocol, but it specifies which other specifications implementations are supposed to follow to be compliant with Web Real-Time Communication (WebRTC)."];
  cites -> RFC8825;
  RFC7656 [label="RFC7656
A Taxonomy of Semantics and Mechanisms
for Real-Time Transport Protocol (RTP)
Sources
2015", shape=ellipse, URL="RFC7656.html", target="_top", tooltip="The terminology about, and associations among, Real-time Transport Protocol (RTP) sources can be complex and somewhat opaque.  This document describes a number of existing and proposed properties and relationships among RTP sources and defines common terminology for discussing protocol entities and their relationships."];
  cites -> RFC7656;
  RFC8826 [label="RFC8826
Security Considerations for WebRTC
2021", shape=ellipse, URL="RFC8826.html", target="_top", tooltip="WebRTC is a protocol suite for use with real-time applications that can be deployed in browsers -- real-time communication on the Web.  This document defines the WebRTC threat model and analyzes the security threats of WebRTC in that model."];
  cites -> RFC8826;
  RFC8827 [label="RFC8827
WebRTC Security Architecture
2021", shape=ellipse, URL="RFC8827.html", target="_top", tooltip="This document defines the security architecture for WebRTC, a protocol suite intended for use with real-time applications that can be deployed in browsers -- real-time communication on the Web."];
  cites -> RFC8827;
  RFC2119 [label="RFC2119
Key words for use in RFCs to Indicate
Requirement Levels
1997", shape=ellipse, URL="RFC2119.html", target="_top", tooltip="In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements."];
  cites -> RFC2119;
  RFC8174 [label="RFC8174
Ambiguity of Uppercase vs Lowercase in
RFC 2119 Key Words
2017", shape=ellipse, URL="RFC8174.html", target="_top", tooltip="RFC 2119 specifies common key words that may be used in protocol specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings."];
  cites -> RFC8174;
  RFC8837 [label="RFC8837
Differentiated Services Code Point
(DSCP) Packet Markings for WebRTC QoS
2021", shape=ellipse, URL="RFC8837.html", target="_top", tooltip="Networks can provide different forwarding treatments for individual packets based on Differentiated Services Code Point (DSCP) values on a per-hop basis.  This document provides the recommended DSCP values for web browsers to use for various classes of Web Real-Time Communication (WebRTC) traffic."];
  cites -> RFC8837;
  RFC8656 [label="RFC8656
Traversal Using Relays around NAT
(TURN): Relay Extensions to Session
Traversal Utilities for NAT (STUN)
2020", shape=ellipse, URL="RFC8656.html", target="_top", tooltip="If a host is located behind a NAT, it can be impossible for that host to communicate directly with other hosts (peers) in certain situations. In these situations, it is necessary for the host to use the services of an intermediate node that acts as a communication relay. This specification defines a protocol, called Traversal Using Relays around NAT (TURN), that allows the host to control the operation of the relay and to exchange packets with its peers using the relay. TURN differs from other relay control protocols in that it allows a client to communicate with multiple peers using a single relay address. The TURN protocol was designed to be used as part of the Interactive Connectivity Establishment (ICE) approach to NAT traversal, though it can also be used without ICE. This document obsoletes RFCs 5766 and 6156."];
  cites -> RFC8656;
  RFC5389 [label="RFC5389
Session Traversal Utilities for NAT
(STUN)
2008", shape=ellipse, URL="RFC5389.html", target="_top", tooltip="Session Traversal Utilities for NAT (STUN) is a protocol that serves as a tool for other protocols in dealing with Network Address Translator (NAT) traversal. It can be used by an endpoint to determine the IP address and port allocated to it by a NAT. It can also be used to check connectivity between two endpoints, and as a keep-alive protocol to maintain NAT bindings. STUN works with many existing NATs, and does not require any special behavior from them. STUN is not a NAT traversal solution by itself. Rather, it is a tool to be used in the context of a NAT traversal solution. This is an important change from the previous version of this specification (RFC 3489), which presented STUN as a complete solution. This document obsoletes RFC 3489. [STANDARDS-TRACK]"];
  cites -> RFC5389;
  RFC8445 [label="RFC8445
Interactive Connectivity Establishment
(ICE): A Protocol for Network Address
Translator (NAT) Traversal
2018", shape=ellipse, URL="RFC8445.html", target="_top", tooltip="This document describes a protocol for Network Address Translator (NAT) traversal for UDP-based communication. This protocol is called Interactive Connectivity Establishment (ICE). ICE makes use of the Session Traversal Utilities for NAT (STUN) protocol and its extension, Traversal Using Relay NAT (TURN). This document obsoletes RFC 5245."];
  cites -> RFC8445;
  RFC8446 [label="RFC8446
The Transport Layer Security (TLS)
Protocol Version 1.3
2018", shape=ellipse, URL="RFC8446.html", target="_top", tooltip="This document specifies version 1.3 of the Transport Layer Security (TLS) protocol. TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery. This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961. This document also specifies new requirements for TLS 1.2 implementations."];
  cites -> RFC8446;
  RFC6347 [label="RFC6347
Datagram Transport Layer Security
Version 1.2
2012", shape=ellipse, URL="RFC6347.html", target="_top", tooltip="This document specifies version 1.2 of the Datagram Transport Layer Security (DTLS) protocol.  The DTLS protocol provides communications privacy for datagram protocols.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  The DTLS protocol is based on the Transport Layer Security (TLS) protocol and provides equivalent security guarantees.  Datagram semantics of the underlying transport are preserved by the DTLS protocol.  This document updates DTLS 1.0 to work with TLS version 1.2. [STANDARDS-TRACK]"];
  cites -> RFC6347;
  RFC8421 [label="RFC8421
Guidelines for Multihomed and IPv4/IPv6
Dual-Stack Interactive Connectivity
Establishment (ICE)
2018", shape=ellipse, URL="RFC8421.html", target="_top", tooltip="This document provides guidelines on how to make Interactive Connectivity Establishment (ICE) conclude faster in multihomed and IPv4/IPv6 dual-stack scenarios where broken paths exist.  The provided guidelines are backward compatible with the original ICE specification (see RFC 5245)."];
  cites -> RFC8421;
  RFC6724 [label="RFC6724
Default Address Selection for Internet
Protocol Version 6 (IPv6)
2012", shape=ellipse, URL="RFC6724.html", target="_top", tooltip="This document describes two algorithms, one for source address selection and one for destination address selection. The algorithms specify default behavior for all Internet Protocol version 6 (IPv6) implementations. They do not override choices made by applications or upper-layer protocols, nor do they preclude the development of more advanced mechanisms for address selection. The two algorithms share a common context, including an optional mechanism for allowing administrators to provide policy that can override the default behavior. In dual-stack implementations, the destination address selection algorithm can consider both IPv4 and IPv6 addresses -- depending on the available source addresses, the algorithm might prefer IPv6 addresses over IPv4 addresses, or vice versa. Default address selection as defined in this specification applies to all IPv6 nodes, including both hosts and routers. This document obsoletes RFC 3484. [STANDARDS-TRACK]"];
  cites -> RFC6724;
  RFC4941 [label="RFC4941
Privacy Extensions for Stateless Address
Autoconfiguration in IPv6
2007", shape=ellipse, URL="RFC4941.html", target="_top", tooltip="Nodes use IPv6 stateless address autoconfiguration to generate addresses using a combination of locally available information and information advertised by routers.  Addresses are formed by combining network prefixes with an interface identifier.  On an interface that contains an embedded IEEE Identifier, the interface identifier is typically derived from it.  On other interface types, the interface identifier is generated through other means, for example, via random number generation.  This document describes an extension to IPv6 stateless address autoconfiguration for interfaces whose interface identifier is derived from an IEEE identifier.  Use of the extension causes nodes to generate global scope addresses from interface identifiers that change over time, even in cases where the interface contains an embedded IEEE identifier.  Changing the interface identifier (and the global scope addresses generated from it) over time makes it more difficult for eavesdroppers and other information collectors to identify when different addresses used in different transactions actually correspond to the same node. [STANDARDS-TRACK]"];
  cites -> RFC4941;
  RFC3484 [label="RFC3484
Default Address Selection for Internet
Protocol version 6 (IPv6)
2003", shape=ellipse, URL="RFC3484.html", target="_top", tooltip="This document describes two algorithms, for source address selection and for destination address selection.  The algorithms specify default behavior for all Internet Protocol version 6 (IPv6) implementations.  They do not override choices made by applications or upper-layer protocols, nor do they preclude the development of more advanced mechanisms for address selection.  The two algorithms share a common context, including an optional mechanism for allowing administrators to provide policy that can override the default behavior.  In dual stack implementations, the destination address selection algorithm can consider both IPv4 and IPv6 addresses - depending on the available source addresses, the algorithm might prefer IPv6 addresses over IPv4 addresses, or vice-versa.  All IPv6 nodes, including both hosts and routers, must implement default address selection as defined in this specification. [STANDARDS-TRACK]"];
  cites -> RFC3484;
  RFC5014 [label="RFC5014
IPv6 Socket API for Source Address
Selection
2007", shape=ellipse, URL="RFC5014.html", target="_top", tooltip="The IPv6 default address selection document (RFC 3484) describes the rules for selecting source and destination IPv6 addresses, and indicates that applications should be able to reverse the sense of some of the address selection rules through some unspecified API.  However, no such socket API exists in the basic (RFC 3493) or advanced (RFC 3542) IPv6 socket API documents.  This document fills that gap partially by specifying new socket-level options for source address selection and flags for the getaddrinfo() API to specify address selection based on the source address preference in accordance with the socket-level options that modify the default source address selection algorithm.  The socket API described in this document will be particularly useful for IPv6 applications that want to choose between temporary and public addresses, and for Mobile IPv6 aware applications that want to use the care-of address for communication.  It also specifies socket options and flags for selecting Cryptographically Generated Address (CGA) or non-CGA source addresses.  This memo provides information for the Internet community."];
  cites -> RFC5014;
  RFC5128 [label="RFC5128
State of Peer-to-Peer (P2P)
Communication across Network Address
Translators (NATs)
2008", shape=ellipse, URL="RFC5128.html", target="_top", tooltip="This memo documents the various methods known to be in use by applications to establish direct communication in the presence of Network Address Translators (NATs) at the current time.  Although this memo is intended to be mainly descriptive, the Security Considerations section makes some purely advisory recommendations about how to deal with security vulnerabilities the applications could inadvertently create when using the methods described.  This memo covers NAT traversal approaches used by both TCP- and UDP-based applications.  This memo is not an endorsement of the methods described, but merely an attempt to capture them in a document.  This memo provides information for the Internet community."];
  cites -> RFC5128;
  RFC8155 [label="RFC8155
Traversal Using Relays around NAT (TURN)
Server Auto Discovery
2017", shape=ellipse, URL="RFC8155.html", target="_top", tooltip="Current Traversal Using Relays around NAT (TURN) server discovery mechanisms are relatively static and limited to explicit configuration. These are usually under the administrative control of the application or TURN service provider, and not the enterprise, ISP, or the network in which the client is located. Enterprises and ISPs wishing to provide their own TURN servers need auto-discovery mechanisms that a TURN client could use with minimal or no configuration. This document describes three such mechanisms for TURN server discovery. This document updates RFC 5766 to relax the requirement for mutual authentication in certain cases."];
  cites -> RFC8155;
  RFC6062 [label="RFC6062
Traversal Using Relays around NAT (TURN)
Extensions for TCP Allocations
2010", shape=ellipse, URL="RFC6062.html", target="_top", tooltip="This specification defines an extension of Traversal Using Relays around NAT (TURN), a relay protocol for Network Address Translator (NAT) traversal.  This extension allows a TURN client to request TCP allocations, and defines new requests and indications for the TURN server to open and accept TCP connections with the client\'s peers.  TURN and this extension both purposefully restrict the ways in which the relayed address can be used.  In particular, it prevents users from running general-purpose servers from ports obtained from the TURN server. [STANDARDS-TRACK]"];
  cites -> RFC6062;
  RFC6544 [label="RFC6544
TCP Candidates with Interactive
Connectivity Establishment (ICE)
2012", shape=ellipse, URL="RFC6544.html", target="_top", tooltip="Interactive Connectivity Establishment (ICE) defines a mechanism for NAT traversal for multimedia communication protocols based on the offer/answer model of session negotiation.  ICE works by providing a set of candidate transport addresses for each media stream, which are then validated with peer-to-peer connectivity checks based on Session Traversal Utilities for NAT (STUN).  ICE provides a general framework for describing candidates but only defines UDP-based media streams.  This specification extends ICE to TCP-based media, including the ability to offer a mix of TCP and UDP-based candidates for a single stream. [STANDARDS-TRACK]"];
  cites -> RFC6544;
  RFC4571 [label="RFC4571
Framing Real-time Transport Protocol
(RTP) and RTP Control Protocol (RTCP)
Packets over Connection-Oriented
Transport
2006", shape=ellipse, URL="RFC4571.html", target="_top", tooltip="This memo defines a method for framing Real-time Transport Protocol (RTP) and RTP Control Protocol (RTCP) packets onto connection-oriented transport (such as TCP).  The memo also defines how session descriptions may specify RTP streams that use the framing method. [STANDARDS-TRACK]"];
  cites -> RFC4571;
  RFC7639 [label="RFC7639
The ALPN HTTP Header Field
2015", shape=ellipse, URL="RFC7639.html", target="_top", tooltip="This specification allows HTTP CONNECT requests to indicate what protocol is intended to be used within the tunnel once established, using the ALPN header field."];
  cites -> RFC7639;
  RFC7231 [label="RFC7231
Hypertext Transfer Protocol (HTTP/1.1):
Semantics and Content
2014", shape=ellipse, URL="RFC7231.html", target="_top", tooltip="The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation."];
  cites -> RFC7231;
  RFC7235 [label="RFC7235
Hypertext Transfer Protocol (HTTP/1.1):
Authentication
2014", shape=ellipse, URL="RFC7235.html", target="_top", tooltip="The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypermedia information systems.  This document defines the HTTP Authentication framework."];
  cites -> RFC7235;
  RFC8834 [label="RFC8834
Media Transport and Use of RTP in WebRTC
2021", shape=ellipse, URL="RFC8834.html", target="_top", tooltip="The framework for Web Real-Time Communication (WebRTC) provides support for direct interactive rich communication using audio, video, text, collaboration, games, etc.  between two peers' web browsers.  This memo describes the media transport aspects of the WebRTC framework.  It specifies how the Real-time Transport Protocol (RTP) is used in the WebRTC context and gives requirements for which RTP features, profiles, and extensions need to be supported."];
  cites -> RFC8834;
  RFC8083 [label="RFC8083
Multimedia Congestion Control: Circuit
Breakers for Unicast RTP Sessions
2017", shape=ellipse, URL="RFC8083.html", target="_top", tooltip="The Real-time Transport Protocol (RTP) is widely used in telephony, video conferencing, and telepresence applications. Such applications are often run on best-effort UDP/IP networks. If congestion control is not implemented in these applications, then network congestion can lead to uncontrolled packet loss and a resulting deterioration of the user's multimedia experience. The congestion control algorithm acts as a safety measure by stopping RTP flows from using excessive resources and protecting the network from overload. At the time of this writing, however, while there are several proprietary solutions, there is no standard algorithm for congestion control of interactive RTP flows. This document does not propose a congestion control algorithm. It instead defines a minimal set of RTP circuit breakers: conditions under which an RTP sender needs to stop transmitting media data to protect the network from excessive congestion. It is expected that, in the absence of long-lived excessive congestion, RTP applications running on best-effort IP networks will be able to operate without triggering these circuit breakers. To avoid triggering the RTP circuit breaker, any Standards Track congestion control algorithms defined for RTP will need to operate within the envelope set by these RTP circuit breaker algorithms."];
  cites -> RFC8083;
  RFC8836 [label="RFC8836
Congestion Control Requirements for
Interactive Real-Time Media
2021", shape=ellipse, URL="RFC8836.html", target="_top", tooltip="Congestion control is needed for all data transported across the Internet, in order to promote fair usage and prevent congestion collapse. The requirements for interactive, point-to-point real-time multimedia, which needs low-delay, semi-reliable data delivery, are different from the requirements for bulk transfer like FTP or bursty transfers like web pages. Due to an increasing amount of RTP-based real-time media traffic on the Internet (e.g., with the introduction of the Web Real-Time Communication (WebRTC)), it is especially important to ensure that this kind of traffic is congestion controlled. This document describes a set of requirements that can be used to evaluate other congestion control mechanisms in order to figure out their fitness for this purpose, and in particular to provide a set of possible requirements for a real-time media congestion avoidance technique."];
  cites -> RFC8836;
  RFC8831 [label="RFC8831
WebRTC Data Channels
2021", shape=ellipse, URL="RFC8831.html", target="_top", tooltip="The WebRTC framework specifies protocol support for direct, interactive, rich communication using audio, video, and data between two peers' web browsers.  This document specifies the non-media data transport aspects of the WebRTC framework.  It provides an architectural overview of how the Stream Control Transmission Protocol (SCTP) is used in the WebRTC context as a generic transport service that allows web browsers to exchange generic data from peer to peer."];
  cites -> RFC8831;
  RFC8261 [label="RFC8261
Datagram Transport Layer Security (DTLS)
Encapsulation of SCTP Packets
2017", shape=ellipse, URL="RFC8261.html", target="_top", tooltip="The Stream Control Transmission Protocol (SCTP) is a transport protocol originally defined to run on top of the network protocols IPv4 or IPv6.  This document specifies how SCTP can be used on top of the Datagram Transport Layer Security (DTLS) protocol.  Using the encapsulation method described in this document, SCTP is unaware of the protocols being used below DTLS; hence, explicit IP addresses cannot be used in the SCTP control chunks.  As a consequence, the SCTP associations carried over DTLS can only be single-homed."];
  cites -> RFC8261;
  RFC8841 [label="RFC8841
Session Description Protocol (SDP)
Offer/Answer Procedures for Stream
Control Transmission Protocol (SCTP)
over Datagram Transport Layer Security
(DTLS) Transport
2021", shape=ellipse, URL="RFC8841.html", target="_top", tooltip="The Stream Control Transmission Protocol (SCTP) is a transport protocol used to establish associations between two endpoints. RFC 8261 specifies how SCTP can be used on top of the Datagram Transport Layer Security (DTLS) protocol, which is referred to as SCTP-over-DTLS. This specification defines the following new Session Description Protocol (SDP) protocol identifiers (proto values): UDP/DTLS/SCTP and TCP/DTLS/SCTP. This specification also specifies how to use the new proto values with the SDP offer/answer mechanism for negotiating SCTP-over-DTLS associations."];
  cites -> RFC8841;
  RFC8260 [label="RFC8260
Stream Schedulers and User Message
Interleaving for the Stream Control
Transmission Protocol
2017", shape=ellipse, URL="RFC8260.html", target="_top", tooltip="The Stream Control Transmission Protocol (SCTP) is a message-oriented transport protocol supporting arbitrarily large user messages. This document adds a new chunk to SCTP for carrying payload data. This allows a sender to interleave different user messages that would otherwise result in head-of-line blocking at the sender. The interleaving of user messages is required for WebRTC data channels. Whenever an SCTP sender is allowed to send user data, it may choose from multiple outgoing SCTP streams. Multiple ways for performing this selection, called stream schedulers, are defined in this document. A stream scheduler can choose to either implement, or not implement, user message interleaving."];
  cites -> RFC8260;
  RFC8832 [label="RFC8832
WebRTC Data Channel Establishment
Protocol
2021", shape=ellipse, URL="RFC8832.html", target="_top", tooltip="The WebRTC framework specifies protocol support for direct interactive rich communication using audio, video, and data between two peers' web browsers.  This document specifies a simple protocol for establishing symmetric data channels between the peers.  It uses a two-way handshake and allows sending of user data without waiting for the handshake to complete."];
  cites -> RFC8832;
  RFC5764 [label="RFC5764
Datagram Transport Layer Security (DTLS)
Extension to Establish Keys for the
Secure Real-time Transport Protocol
(SRTP)
2010", shape=ellipse, URL="RFC5764.html", target="_top", tooltip="This document describes a Datagram Transport Layer Security (DTLS) extension to establish keys for Secure RTP (SRTP) and Secure RTP Control Protocol (SRTCP) flows.  DTLS keying happens on the media path, independent of any out-of-band signalling channel present. [STANDARDS-TRACK]"];
  cites -> RFC5764;
  RFC8842 [label="RFC8842
Session Description Protocol (SDP)
Offer/Answer Considerations for Datagram
Transport Layer Security (DTLS) and
Transport Layer Security (TLS)
2021", shape=ellipse, URL="RFC8842.html", target="_top", tooltip="This document defines the Session Description Protocol (SDP) offer/answer procedures for negotiating and establishing a Datagram Transport Layer Security (DTLS) association. The document also defines the criteria for when a new DTLS association must be established. The document updates RFCs 5763 and 7345 by replacing common SDP offer/answer procedures with a reference to this specification. This document defines a new SDP media-level attribute, tls-id. This document also defines how the tls-id attribute can be used for negotiating and establishing a Transport Layer Security (TLS) connection, in conjunction with the procedures in RFCs 4145 and 8122."];
  cites -> RFC8842;
  RFC7983 [label="RFC7983
Multiplexing Scheme Updates for Secure
Real-time Transport Protocol (SRTP)
Extension for Datagram Transport Layer
Security (DTLS)
2016", shape=ellipse, URL="RFC7983.html", target="_top", tooltip="This document defines how Datagram Transport Layer Security (DTLS), Real-time Transport Protocol (RTP), RTP Control Protocol (RTCP), Session Traversal Utilities for NAT (STUN), Traversal Using Relays around NAT (TURN), and ZRTP packets are multiplexed on a single receiving socket. It overrides the guidance from RFC 5764 (SRTP Extension for DTLS), which suffered from four issues described and fixed in this document. This document updates RFC 5764."];
  cites -> RFC7983;
  RFC8833 [label="RFC8833
Application-Layer Protocol Negotiation
(ALPN) for WebRTC
2021", shape=ellipse, URL="RFC8833.html", target="_top", tooltip="This document specifies two Application-Layer Protocol Negotiation (ALPN) labels for use with Web Real-Time Communication (WebRTC).  The webrtc label identifies regular WebRTC: a DTLS session that is used to establish keys for the Secure Real-time Transport Protocol (SRTP) or to establish data channels using the Stream Control Transmission Protocol (SCTP) over DTLS.  The c-webrtc label describes the same protocol, but the peers also agree to maintain the confidentiality of the media by not sharing it with other applications."];
  cites -> RFC8833;
  RFC4594 [label="RFC4594
Configuration Guidelines for DiffServ
Service Classes
2006", shape=ellipse, URL="RFC4594.html", target="_top", tooltip="This document describes service classes configured with Diffserv and recommends how they can be used and how to construct them using Differentiated Services Code Points (DSCPs), traffic conditioners, Per-Hop Behaviors (PHBs), and Active Queue Management (AQM) mechanisms.  There is no intrinsic requirement that particular DSCPs, traffic conditioners, PHBs, and AQM be used for a certain service class, but as a policy and for interoperability it is useful to apply them consistently.  This memo provides information for the Internet community."];
  cites -> RFC4594;
  RFC8699 [label="RFC8699
Coupled Congestion Control for RTP Media
2020", shape=ellipse, URL="RFC8699.html", target="_top", tooltip="When multiple congestion-controlled Real-time Transport Protocol (RTP) sessions traverse the same network bottleneck, combining their controls can improve the total on-the-wire behavior in terms of delay, loss, and fairness.  This document describes such a method for flows that have the same sender, in a way that is as flexible and simple as possible while minimizing the number of changes needed to existing RTP applications.  This document also specifies how to apply the method for the Network-Assisted Dynamic Adaptation (NADA) congestion control algorithm and provides suggestions on how to apply it to other congestion control algorithms."];
  cites -> RFC8699;
  RFC7657 [label="RFC7657
Differentiated Services (Diffserv) and
Real-Time Communication
2015", shape=ellipse, URL="RFC7657.html", target="_top", tooltip="This memo describes the interaction between Differentiated Services (Diffserv) network quality-of-service (QoS) functionality and real- time network communication, including communication based on the Real-time Transport Protocol (RTP).  Diffserv is based on network nodes applying different forwarding treatments to packets whose IP headers are marked with different Diffserv Codepoints (DSCPs).  WebRTC applications, as well as some conferencing applications, have begun using the Session Description Protocol (SDP) bundle negotiation mechanism to send multiple traffic streams with different QoS requirements using the same network 5-tuple.  The results of using multiple DSCPs to obtain different QoS treatments within a single network 5-tuple have transport protocol interactions, particularly with congestion control functionality (e.g., reordering).  In addition, DSCP markings may be changed or removed between the traffic source and destination.  This memo covers the implications of these Diffserv aspects for real-time network communication, including WebRTC."];
  cites -> RFC7657;

  rev_cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  rev_cites -> RFC8835;
  RFC8825 [label="RFC8825
Overview: Real-Time Protocols for
Browser-Based Applications
2021", shape=ellipse, URL="RFC8825.html", target="_top", tooltip="This document gives an overview and context of a protocol suite intended for use with real-time applications that can be deployed in browsers -- real-time communication on the Web. It intends to serve as a starting and coordination point to make sure that (1) all the parts that are needed to achieve this goal are findable and (2) the parts that belong in the Internet protocol suite are fully specified and on the right publication track. This document is an applicability statement -- it does not itself specify any protocol, but it specifies which other specifications implementations are supposed to follow to be compliant with Web Real-Time Communication (WebRTC)."];
  RFC8825 -> rev_cites;
  RFC8828 [label="RFC8828
WebRTC IP Address Handling Requirements
2021", shape=ellipse, URL="RFC8828.html", target="_top", tooltip="This document provides information and requirements for how IP addresses should be handled by Web Real-Time Communication (WebRTC) implementations."];
  RFC8828 -> rev_cites;
  RFC8833 [label="RFC8833
Application-Layer Protocol Negotiation
(ALPN) for WebRTC
2021", shape=ellipse, URL="RFC8833.html", target="_top", tooltip="This document specifies two Application-Layer Protocol Negotiation (ALPN) labels for use with Web Real-Time Communication (WebRTC).  The webrtc label identifies regular WebRTC: a DTLS session that is used to establish keys for the Secure Real-time Transport Protocol (SRTP) or to establish data channels using the Stream Control Transmission Protocol (SCTP) over DTLS.  The c-webrtc label describes the same protocol, but the peers also agree to maintain the confidentiality of the media by not sharing it with other applications."];
  RFC8833 -> rev_cites;
  RFC8837 [label="RFC8837
Differentiated Services Code Point
(DSCP) Packet Markings for WebRTC QoS
2021", shape=ellipse, URL="RFC8837.html", target="_top", tooltip="Networks can provide different forwarding treatments for individual packets based on Differentiated Services Code Point (DSCP) values on a per-hop basis.  This document provides the recommended DSCP values for web browsers to use for various classes of Web Real-Time Communication (WebRTC) traffic."];
  RFC8837 -> rev_cites;
  RFC9248 [label="RFC9248
Interoperability Profile for Relay User
Equipment
2022", shape=ellipse, URL="RFC9248.html", target="_top", tooltip="Video Relay Service (VRS) is a term used to describe a method by which a hearing person can communicate with a sign language speaker who is deaf, deafblind, or hard of hearing (HoH) or has a speech disability using an interpreter (i.e., a Communications Assistant (CA)) connected via a videophone to the sign language speaker and an audio telephone call to the hearing user.  The CA interprets using sign language on the videophone link and voice on the telephone link.  Often the interpreters may be employed by a company or agency, termed a provider in this document.  The provider also provides a video service that allows users to connect video devices to their service and subsequently to CAs and other sign language speakers.  It is desirable that the videophones used by the sign language speaker conform to a standard so that any device may be used with any provider and that direct video calls between sign language speakers work.  This document describes the interface between a videophone and a provider."];
  RFC9248 -> rev_cites;
  RFC9317 [label="RFC9317
Operational Considerations for Streaming
Media
2022", shape=ellipse, URL="RFC9317.html", target="_top", tooltip="This document provides an overview of operational networking and transport protocol issues that pertain to the quality of experience (QoE) when streaming video and other high-bitrate media over the Internet. This document explains the characteristics of streaming media delivery that have surprised network designers or transport experts who lack specific media expertise, since streaming media highlights key differences between common assumptions in existing networking practices and observations of media delivery issues encountered when streaming media over those existing networks."];
  RFC9317 -> rev_cites;
}
