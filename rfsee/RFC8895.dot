digraph Flow {
  layout=twopi;
  root=RFC8895;
  overlap=false;
  RFC8895 [label="RFC8895
Application-Layer Traffic Optimization
(ALTO) Incremental Updates Using Server-
Sent Events (SSE)
2020", shape=ellipse, fillcolor="#e8f0ff", tooltip="The Application-Layer Traffic Optimization (ALTO) protocol (RFC 7285) provides network-related information, called network information resources, to client applications so that clients can make informed decisions in utilizing network resources.  This document presents a mechanism to allow an ALTO server to push updates to ALTO clients to achieve two benefits: (1) updates can be incremental, in that if only a small section of an information resource changes, the ALTO server can send just the changes and (2) updates can be immediate, in that the ALTO server can send updates as soon as they are available.", style=filled, fillcolor=green, fontsize=18, penwidth=3, fontweight=bold]; 

  obs_by [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  obs_by -> RFC8895;

  obs [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  RFC8895 -> obs;

  updates [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  RFC8895 -> updates;

  updated_by [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  updated_by -> RFC8895;

  cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  RFC8895 -> cites;
  RFC7285 [label="RFC7285
Application-Layer Traffic Optimization
(ALTO) Protocol
2014", shape=ellipse, URL="RFC7285.html", target="_top", tooltip="Applications using the Internet already have access to some topology information of Internet Service Provider (ISP) networks. For example, views to Internet routing tables at Looking Glass servers are available and can be practically downloaded to many network application clients. What is missing is knowledge of the underlying network topologies from the point of view of ISPs. In other words, what an ISP prefers in terms of traffic optimization -- and a way to distribute it. The Application-Layer Traffic Optimization (ALTO) services defined in this document provide network information (e.g., basic network location structure and preferences of network paths) with the goal of modifying network resource consumption patterns while maintaining or improving application performance. The basic information of ALTO is based on abstract maps of a network. These maps provide a simplified view, yet enough information about a network for applications to effectively utilize them. Additional services are built on top of the maps. This document describes a protocol implementing the ALTO services. Although the ALTO services would primarily be provided by ISPs, other entities, such as content service providers, could also provide ALTO services. Applications that could use the ALTO services are those that have a choice to which end points to connect. Examples of such applications are peer-to-peer (P2P) and content delivery networks."];
  cites -> RFC7285;
  RFC4960 [label="RFC4960
Stream Control Transmission Protocol
2007", shape=ellipse, URL="RFC4960.html", target="_top", tooltip="This document obsoletes RFC 2960 and RFC 3309. It describes the Stream Control Transmission Protocol (SCTP). SCTP is designed to transport Public Switched Telephone Network (PSTN) signaling messages over IP networks, but is capable of broader applications. SCTP is a reliable transport protocol operating on top of a connectionless packet network such as IP. It offers the following services to its users: -- acknowledged error-free non-duplicated transfer of user data, -- data fragmentation to conform to discovered path MTU size, -- sequenced delivery of user messages within multiple streams, with an option for order-of-arrival delivery of individual user messages, -- optional bundling of multiple user messages into a single SCTP packet, and -- network-level fault tolerance through supporting of multi-homing at either or both ends of an association. The design of SCTP includes appropriate congestion avoidance behavior and resistance to flooding and masquerade attacks. [STANDARDS-TRACK]"];
  cites -> RFC4960;
  RFC2119 [label="RFC2119
Key words for use in RFCs to Indicate
Requirement Levels
1997", shape=ellipse, URL="RFC2119.html", target="_top", tooltip="In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements."];
  cites -> RFC2119;
  RFC8174 [label="RFC8174
Ambiguity of Uppercase vs Lowercase in
RFC 2119 Key Words
2017", shape=ellipse, URL="RFC8174.html", target="_top", tooltip="RFC 2119 specifies common key words that may be used in protocol specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings."];
  cites -> RFC8174;
  RFC7396 [label="RFC7396
JSON Merge Patch
2014", shape=ellipse, URL="RFC7396.html", target="_top", tooltip="This specification defines the JSON merge patch format and processing rules.  The merge patch format is primarily intended for use with the HTTP PATCH method as a means of describing a set of modifications to a target resource's content."];
  cites -> RFC7396;
  RFC5789 [label="RFC5789
PATCH Method for HTTP
2010", shape=ellipse, URL="RFC5789.html", target="_top", tooltip="Several applications extending the Hypertext Transfer Protocol (HTTP) require a feature to do partial resource modification.  The existing HTTP PUT method only allows a complete replacement of a document.  This proposal adds a new HTTP method, PATCH, to modify an existing HTTP resource. [STANDARDS-TRACK]"];
  cites -> RFC5789;
  RFC6902 [label="RFC6902
JavaScript Object Notation (JSON) Patch
2013", shape=ellipse, URL="RFC6902.html", target="_top", tooltip="JSON Patch defines a JSON document structure for expressing a sequence of operations to apply to a JavaScript Object Notation (JSON) document; it is suitable for use with the HTTP PATCH method.  The application/json-patch+json media type is used to identify such patch documents."];
  cites -> RFC6902;
  RFC7540 [label="RFC7540
Hypertext Transfer Protocol Version 2
(HTTP/2)
2015", shape=ellipse, URL="RFC7540.html", target="_top", tooltip="This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection. It also introduces unsolicited push of representations from servers to clients. This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax. HTTP's existing semantics remain unchanged."];
  cites -> RFC7540;
  RFC7230 [label="RFC7230
Hypertext Transfer Protocol (HTTP/1.1):
Message Syntax and Routing
2014", shape=ellipse, URL="RFC7230.html", target="_top", tooltip="The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the http and https Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations."];
  cites -> RFC7230;
  RFC7231 [label="RFC7231
Hypertext Transfer Protocol (HTTP/1.1):
Semantics and Content
2014", shape=ellipse, URL="RFC7231.html", target="_top", tooltip="The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation."];
  cites -> RFC7231;
  RFC6838 [label="RFC6838
Media Type Specifications and
Registration Procedures
2013", shape=ellipse, URL="RFC6838.html", target="_top", tooltip="This document defines procedures for the specification and registration of media types for use in HTTP, MIME, and other Internet protocols.  This memo documents an Internet Best Current Practice."];
  cites -> RFC6838;
  RFC2387 [label="RFC2387
The MIME Multipart/Related Content-type
1998", shape=ellipse, URL="RFC2387.html", target="_top", tooltip="This document defines the Multipart/Related content-type and provides examples of its use. [STANDARDS-TRACK]"];
  cites -> RFC2387;
  RFC3986 [label="RFC3986
Uniform Resource Identifier (URI):
Generic Syntax
2005", shape=ellipse, URL="RFC3986.html", target="_top", tooltip="A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme. [STANDARDS-TRACK]"];
  cites -> RFC3986;
  RFC8259 [label="RFC8259
The JavaScript Object Notation (JSON)
Data Interchange Format
2017", shape=ellipse, URL="RFC8259.html", target="_top", tooltip="JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format. It was derived from the ECMAScript Programming Language Standard. JSON defines a small set of formatting rules for the portable representation of structured data. This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance."];
  cites -> RFC8259;

  rev_cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  rev_cites -> RFC8895;
  RFC8896 [label="RFC8896
Application-Layer Traffic Optimization
(ALTO) Cost Calendar
2020", shape=ellipse, URL="RFC8896.html", target="_top", tooltip="This document is an extension to the base Application-Layer Traffic Optimization (ALTO) protocol.  It extends the ALTO cost information service so that applications decide not only 'where' to connect but also 'when'.  This is useful for applications that need to perform bulk data transfer and would like to schedule these transfers during an off-peak hour, for example.  This extension introduces the ALTO Cost Calendar with which an ALTO Server exposes ALTO cost values in JSON arrays where each value corresponds to a given time interval.  The time intervals, as well as other Calendar attributes, are specified in the Information Resources Directory and ALTO Server responses."];
  RFC8896 -> rev_cites;
  RFC9240 [label="RFC9240
An Extension for Application-Layer
Traffic Optimization (ALTO): Entity
Property Maps
2022", shape=ellipse, URL="RFC9240.html", target="_top", tooltip="This document specifies an extension to the base Application-Layer Traffic Optimization (ALTO) Protocol that generalizes the concept of endpoint properties, which have been tied to IP addresses so far, to entities defined by a wide set of objects.  Further, these properties are presented as maps, similar to the network and cost maps in the base ALTO Protocol.  While supporting the endpoints and related Endpoint Property Service defined in RFC 7285, the ALTO Protocol is extended in two major directions.  First, from endpoints restricted to IP addresses to entities covering a wider and extensible set of objects; second, from properties for specific endpoints to entire entity property maps.  These extensions introduce additional features that allow entities and property values to be specific to a given information resource.  This is made possible by a generic and flexible design of entity and property types."];
  RFC9240 -> rev_cites;
  RFC9241 [label="RFC9241
Content Delivery Network Interconnection
(CDNI) Footprint and Capabilities
Advertisement Using Application-Layer
Traffic Optimization (ALTO)
2022", shape=ellipse, URL="RFC9241.html", target="_top", tooltip="The Content Delivery Networks Interconnection (CDNI) framework in RFC 6707 defines a set of protocols to interconnect CDNs to achieve multiple goals, including extending the reach of a given CDN.  A CDNI Request Routing Footprint & Capabilities Advertisement interface (FCI) is needed to achieve the goals of a CDNI.  RFC 8008 defines the FCI semantics and provides guidelines on the FCI protocol, but the exact protocol is not specified.  This document defines a new Application-Layer Traffic Optimization (ALTO) service, called CDNI Advertisement Service, that provides an implementation of the FCI, following the guidelines defined in RFC 8008."];
  RFC9241 -> rev_cites;
  RFC9275 [label="RFC9275
An Extension for Application-Layer
Traffic Optimization (ALTO): Path Vector
2022", shape=ellipse, URL="RFC9275.html", target="_top", tooltip="This document is an extension to the base Application-Layer Traffic Optimization (ALTO) protocol.  It extends the ALTO cost map and ALTO property map services so that an application can decide to which endpoint(s) to connect based not only on numerical/ordinal cost values but also on fine-grained abstract information regarding the paths.  This is useful for applications whose performance is impacted by specific components of a network on the end-to-end paths, e.g., they may infer that several paths share common links and prevent traffic bottlenecks by avoiding such paths.  This extension introduces a new abstraction called the Abstract Network Element (ANE) to represent these components and encodes a network path as a vector of ANEs.  Thus, it provides a more complete but still abstract graph representation of the underlying network(s) for informed traffic optimization among endpoints."];
  RFC9275 -> rev_cites;
  RFC9439 [label="RFC9439
Application-Layer Traffic Optimization
(ALTO) Performance Cost Metrics
2023", shape=ellipse, URL="RFC9439.html", target="_top", tooltip="The cost metric is a basic concept in Application-Layer Traffic
Optimization (ALTO), and different applications may use different
types of cost metrics. Since the ALTO base protocol (RFC 7285)
defines only a single cost metric (namely, the generic routingcost
metric), if an application wants to issue a cost map or an endpoint
cost request in order to identify a resource provider that offers
better performance metrics (e.g., lower delay or loss rate), the base
protocol does not define the cost metric to be used. This document addresses this issue by extending the specification to
provide a variety of network performance metrics, including network
delay, delay variation (a.k.a. jitter), packet loss rate, hop count,
and bandwidth. There are multiple sources (e.g., estimations based on measurements
or a Service Level Agreement) available for deriving a performance
metric. This document introduces an additional cost-context field
to the ALTO cost-type field to convey the source of a performance
metric."];
  RFC9439 -> rev_cites;
  RFC9569 [label="RFC9569
The Application-Layer Traffic
Optimization (ALTO) Transport
Information Publication Service (TIPS)
2024", shape=ellipse, URL="RFC9569.html", target="_top", tooltip="Application-Layer Traffic Optimization (ALTO) Protocol (RFC 7285) leverages HTTP/1.1 and is designed for the simple, sequential request-reply use case, in which an ALTO client requests a sequence of information resources and the server responds with the complete content of each resource, one at a time. RFC 8895, which describes ALTO incremental updates using Server-Sent Events (SSE), defines a multiplexing protocol on top of HTTP/1.x, so that an ALTO server can incrementally push resource updates to clients whenever monitored network information resources change, allowing the clients to monitor multiple resources at the same time. However, HTTP/2 and later versions already support concurrent, non-blocking transport of multiple streams in the same HTTP connection. To take advantage of newer HTTP features, this document introduces the ALTO Transport Information Publication Service (TIPS). TIPS uses an incremental RESTful design to give an ALTO client the new capability to explicitly and concurrently (in a non-blocking manner) request (or pull) specific incremental updates using HTTP/2 or HTTP/3, while still functioning for HTTP/1.1."];
  RFC9569 -> rev_cites;
}
