digraph Flow {
  rankdir=LR;
  splines=true;
  concentrate=true;   // merge parallel edges / reduce clutter
  nodesep=0.25;       // horizontal/vertical separation between nodes
  ranksep=0.35;       // separation between ranks (columns in LR)
  RFC7493 [label="RFC7493
The I-JSON Message Format
2015", shape=ellipse, fillcolor="#e8f0ff", tooltip="I-JSON (short for Internet JSON) is a restricted profile of JSON designed to maximize interoperability and increase confidence that software can process it successfully with predictable results.", style=filled, fillcolor=green]; 

  obs_by [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  obs_by -> RFC7493;

  obs [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  RFC7493 -> obs;

  updates [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  RFC7493 -> updates;

  updated_by [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  updated_by -> RFC7493;

  cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  RFC7493 -> cites;
  RFC7159 [label="RFC7159
The JavaScript Object Notation (JSON)
Data Interchange Format
2014", shape=ellipse, URL="RFC7159.html", target="_top", tooltip="JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format. It was derived from the ECMAScript Programming Language Standard. JSON defines a small set of formatting rules for the portable representation of structured data. This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance."];
  cites -> RFC7159;
  RFC2119 [label="RFC2119
Key words for use in RFCs to Indicate
Requirement Levels
1997", shape=ellipse, URL="RFC2119.html", target="_top", tooltip="In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements."];
  cites -> RFC2119;
  RFC3629 [label="RFC3629
UTF-8, a transformation format of ISO
10646
2003", shape=ellipse, URL="RFC3629.html", target="_top", tooltip="ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279."];
  cites -> RFC3629;
  RFC4627 [label="RFC4627
The application/json Media Type for
JavaScript Object Notation (JSON)
2006", shape=ellipse, URL="RFC4627.html", target="_top", tooltip="JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.  This memo provides information for the Internet community."];
  cites -> RFC4627;
  RFC3339 [label="RFC3339
Date and Time on the Internet:
Timestamps
2002", shape=ellipse, URL="RFC3339.html", target="_top", tooltip="This document defines a date and time format for use in Internet protocols that is a profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."];
  cites -> RFC3339;
  RFC4648 [label="RFC4648
The Base16, Base32, and Base64 Data
Encodings
2006", shape=ellipse, URL="RFC4648.html", target="_top", tooltip="This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. [STANDARDS-TRACK]"];
  cites -> RFC4648;

  rev_cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  rev_cites -> RFC7493;
  RFC7638 [label="RFC7638
JSON Web Key (JWK) Thumbprint
2015", shape=ellipse, URL="RFC7638.html", target="_top", tooltip="This specification defines a method for computing a hash value over a JSON Web Key (JWK).  It defines which fields in a JWK are used in the hash computation, the method of creating a canonical form for those fields, and how to convert the resulting Unicode string into a byte sequence to be hashed.  The resulting hash value can be used for identifying or selecting the key represented by the JWK that is the subject of the thumbprint."];
  RFC7638 -> rev_cites;
  RFC7946 [label="RFC7946
The GeoJSON Format
2016", shape=ellipse, URL="RFC7946.html", target="_top", tooltip="GeoJSON is a geospatial data interchange format based on JavaScript Object Notation (JSON).  It defines several types of JSON objects and the manner in which they are combined to represent data about geographic features, their properties, and their spatial extents.  GeoJSON uses a geographic coordinate reference system, World Geodetic System 1984, and units of decimal degrees."];
  RFC7946 -> rev_cites;
  RFC7951 [label="RFC7951
JSON Encoding of Data Modeled with YANG
2016", shape=ellipse, URL="RFC7951.html", target="_top", tooltip="This document defines encoding rules for representing configuration data, state data, parameters of Remote Procedure Call (RPC) operations or actions, and notifications defined using YANG as JavaScript Object Notation (JSON) text."];
  RFC7951 -> rev_cites;
  RFC7975 [label="RFC7975
Request Routing Redirection Interface
for Content Delivery Network (CDN)
Interconnection
2016", shape=ellipse, URL="RFC7975.html", target="_top", tooltip="The Request Routing interface comprises (1) the asynchronous advertisement of footprint and capabilities by a downstream Content Delivery Network (CDN) that allows an upstream CDN to decide whether to redirect particular user requests to that downstream CDN; and (2) the synchronous operation of an upstream CDN requesting whether a downstream CDN is prepared to accept a user request and of a downstream CDN responding with how to actually redirect the user request.  This document describes an interface for the latter part, i.e., the CDNI Request Routing Redirection interface."];
  RFC7975 -> rev_cites;
  RFC8006 [label="RFC8006
Content Delivery Network Interconnection
(CDNI) Metadata
2016", shape=ellipse, URL="RFC8006.html", target="_top", tooltip="The Content Delivery Network Interconnection (CDNI) Metadata interface enables interconnected Content Delivery Networks (CDNs) to exchange content distribution metadata in order to enable content acquisition and delivery.  The CDNI Metadata associated with a piece of content provides a downstream CDN with sufficient information for the downstream CDN to service content requests on behalf of an upstream CDN.  This document describes both a base set of CDNI Metadata and the protocol for exchanging that metadata."];
  RFC8006 -> rev_cites;
  RFC8008 [label="RFC8008
Content Delivery Network Interconnection
(CDNI) Request Routing: Footprint and
Capabilities Semantics
2016", shape=ellipse, URL="RFC8008.html", target="_top", tooltip="This document captures the semantics of the Footprint and Capabilities Advertisement part of the Content Delivery Network Interconnection (CDNI) Request Routing interface, i.e., the desired meaning of Footprint and Capabilities in the CDNI context and what the Footprint & Capabilities Advertisement interface (FCI) offers within CDNI.  The document also provides guidelines for the CDNI FCI protocol.  It further defines a Base Advertisement Object, the necessary registries for capabilities and footprints, and guidelines on how these registries can be extended in the future."];
  RFC8008 -> rev_cites;
  RFC8460 [label="RFC8460
SMTP TLS Reporting
2018", shape=ellipse, URL="RFC8460.html", target="_top", tooltip="A number of protocols exist for establishing encrypted channels between SMTP Mail Transfer Agents (MTAs), including STARTTLS, DNS- Based Authentication of Named Entities (DANE) TLSA, and MTA Strict Transport Security (MTA-STS).  These protocols can fail due to misconfiguration or active attack, leading to undelivered messages or delivery over unencrypted or unauthenticated channels.  This document describes a reporting mechanism and format by which sending systems can share statistics and specific information about potential failures with recipient domains.  Recipient domains can then use this information to both detect potential attacks and diagnose unintentional misconfigurations."];
  RFC8460 -> rev_cites;
  RFC8610 [label="RFC8610
Concise Data Definition Language (CDDL):
A Notational Convention to Express
Concise Binary Object Representation
(CBOR) and JSON Data Structures
2019", shape=ellipse, URL="RFC8610.html", target="_top", tooltip="This document proposes a notational convention to express Concise Binary Object Representation (CBOR) data structures (RFC 7049).  Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON."];
  RFC8610 -> rev_cites;
  RFC8620 [label="RFC8620
The JSON Meta Application Protocol
(JMAP)
2019", shape=ellipse, URL="RFC8620.html", target="_top", tooltip="This document specifies a protocol for clients to efficiently query, fetch, and modify JSON-based data objects, with support for push notification of changes and fast resynchronisation and for out-of- band binary data upload/download."];
  RFC8620 -> rev_cites;
  RFC8785 [label="RFC8785
JSON Canonicalization Scheme (JCS)
2020", shape=ellipse, URL="RFC8785.html", target="_top", tooltip="Cryptographic operations like hashing and signing need the data to be expressed in an invariant format so that the operations are reliably repeatable. One way to address this is to create a canonical representation of the data. Canonicalization also permits data to be exchanged in its original form on the wire while cryptographic operations performed on the canonicalized counterpart of the data in the producer and consumer endpoints generate consistent results. This document describes the JSON Canonicalization Scheme (JCS). This specification defines how to create a canonical representation of JSON data by building on the strict serialization methods for JSON primitives defined by ECMAScript, constraining JSON data to the Internet JSON (I-JSON) subset, and by using deterministic property sorting."];
  RFC8785 -> rev_cites;
  RFC8801 [label="RFC8801
Discovering Provisioning Domain Names
and Data
2020", shape=ellipse, URL="RFC8801.html", target="_top", tooltip="Provisioning Domains (PvDs) are defined as consistent sets of network configuration information. PvDs allows hosts to manage connections to multiple networks and interfaces simultaneously, such as when a home router provides connectivity through both a broadband and cellular network provider. This document defines a mechanism for explicitly identifying PvDs through a Router Advertisement (RA) option. This RA option announces a PvD identifier, which hosts can compare to differentiate between PvDs. The option can directly carry some information about a PvD and can optionally point to PvD Additional Information that can be retrieved using HTTP over TLS."];
  RFC8801 -> rev_cites;
  RFC8877 [label="RFC8877
Guidelines for Defining Packet
Timestamps
2020", shape=ellipse, URL="RFC8877.html", target="_top", tooltip="Various network protocols make use of binary-encoded timestamps that are incorporated in the protocol packet format, referred to as packet timestamps for short.  This document specifies guidelines for defining packet timestamp formats in networking protocols at various layers.  It also presents three recommended timestamp formats.  The target audience of this document includes network protocol designers.  It is expected that a new network protocol that requires a packet timestamp will, in most cases, use one of the recommended timestamp formats.  If none of the recommended formats fits the protocol requirements, the new protocol specification should specify the format of the packet timestamp according to the guidelines in this document."];
  RFC8877 -> rev_cites;
  RFC8927 [label="RFC8927
JSON Type Definition
2020", shape=ellipse, URL="RFC8927.html", target="_top", tooltip="This document proposes a format, called JSON Type Definition (JTD), for describing the shape of JavaScript Object Notation (JSON) messages. Its main goals are to enable code generation from schemas as well as portable validation with standardized error indicators. To this end, JTD is intentionally limited to be no more expressive than the type systems of mainstream programming languages. This intentional limitation, as well as the decision to make JTD schemas be JSON documents, makes tooling atop of JTD easier to build. This document does not have IETF consensus and is presented here to facilitate experimentation with the concept of JTD."];
  RFC8927 -> rev_cites;
  RFC8941 [label="RFC8941
Structured Field Values for HTTP
2021", shape=ellipse, URL="RFC8941.html", target="_top", tooltip="This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as Structured Fields, Structured Headers, or Structured Trailers.  It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values."];
  RFC8941 -> rev_cites;
  RFC8949 [label="RFC8949
Concise Binary Object Representation
(CBOR)
2020", shape=ellipse, URL="RFC8949.html", target="_top", tooltip="The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack. This document obsoletes RFC 7049, providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049. It does not create a new version of the format."];
  RFC8949 -> rev_cites;
  RFC8984 [label="RFC8984
JSCalendar: A JSON Representation of
Calendar Data
2021", shape=ellipse, URL="RFC8984.html", target="_top", tooltip="This specification defines a data model and JSON representation of calendar data that can be used for storage and data exchange in a calendaring and scheduling environment.  It aims to be an alternative and, over time, successor to the widely deployed iCalendar data format.  It also aims to be unambiguous, extendable, and simple to process.  In contrast to the jCal format, which is also based on JSON, JSCalendar is not a direct mapping from iCalendar but defines the data model independently and expands semantics where appropriate."];
  RFC8984 -> rev_cites;
  RFC9100 [label="RFC9100
Sensor Measurement Lists (SenML)
Features and Versions
2021", shape=ellipse, URL="RFC9100.html", target="_top", tooltip="This short document updates RFC 8428, Sensor Measurement Lists (SenML), by specifying the use of independently selectable SenML Features and mapping them to SenML version numbers."];
  RFC9100 -> rev_cites;
  RFC9237 [label="RFC9237
An Authorization Information Format
(AIF) for Authentication and
Authorization for Constrained
Environments (ACE)
2022", shape=ellipse, URL="RFC9237.html", target="_top", tooltip="Information about which entities are authorized to perform what operations on which constituents of other entities is a crucial component of producing an overall system that is secure. Conveying precise authorization information is especially critical in highly automated systems with large numbers of entities, such as the Internet of Things. This specification provides a generic information model and format for representing such authorization information, as well as two variants of a specific instantiation of that format for use with Representational State Transfer (REST) resources identified by URI path."];
  RFC9237 -> rev_cites;
  RFC9241 [label="RFC9241
Content Delivery Network Interconnection
(CDNI) Footprint and Capabilities
Advertisement Using Application-Layer
Traffic Optimization (ALTO)
2022", shape=ellipse, URL="RFC9241.html", target="_top", tooltip="The Content Delivery Networks Interconnection (CDNI) framework in RFC 6707 defines a set of protocols to interconnect CDNs to achieve multiple goals, including extending the reach of a given CDN.  A CDNI Request Routing Footprint & Capabilities Advertisement interface (FCI) is needed to achieve the goals of a CDNI.  RFC 8008 defines the FCI semantics and provides guidelines on the FCI protocol, but the exact protocol is not specified.  This document defines a new Application-Layer Traffic Optimization (ALTO) service, called CDNI Advertisement Service, that provides an implementation of the FCI, following the guidelines defined in RFC 8008."];
  RFC9241 -> rev_cites;
  RFC9485 [label="RFC9485
I-Regexp: An Interoperable Regular
Expression Format
2023", shape=ellipse, URL="RFC9485.html", target="_top", tooltip="This document specifies I-Regexp, a flavor of regular expression that is limited in scope with the goal of interoperation across many different regular expression libraries."];
  RFC9485 -> rev_cites;
  RFC9535 [label="RFC9535
JSONPath: Query Expressions for JSON
2024", shape=ellipse, URL="RFC9535.html", target="_top", tooltip="JSONPath defines a string syntax for selecting and extracting JSON (RFC 8259) values from within a given JSON value."];
  RFC9535 -> rev_cites;
  RFC9553 [label="RFC9553
JSContact: A JSON Representation of
Contact Data
2024", shape=ellipse, URL="RFC9553.html", target="_top", tooltip="This specification defines a data model and JavaScript Object Notation (JSON) representation of contact card information that can be used for data storage and exchange in address book or directory applications.  It aims to be an alternative to the vCard data format and to be unambiguous, extendable, and simple to process.  In contrast to the JSON-based jCard format, it is not a direct mapping from the vCard data model and expands semantics where appropriate.  Two additional specifications define new vCard elements and how to convert between JSContact and vCard."];
  RFC9553 -> rev_cites;
  RFC9651 [label="RFC9651
Structured Field Values for HTTP
2024", shape=ellipse, URL="RFC9651.html", target="_top", tooltip="This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as Structured Fields, Structured Headers, or Structured Trailers. It is intended for use by specifications of new HTTP fields. This document obsoletes RFC 8941."];
  RFC9651 -> rev_cites;
  RFC9741 [label="RFC9741
Concise Data Definition Language (CDDL):
Additional Control Operators for the
Conversion and Processing of Text
2025", shape=ellipse, URL="RFC9741.html", target="_top", tooltip="The Concise Data Definition Language (CDDL), standardized in RFC 8610, provides control operators as its main language extension point. RFCs have added to this extension point in both an application-specific and a more general way. The present document defines a number of additional generally applicable control operators for text conversion (bytes, integers, printf-style formatting, and JSON) and for an operation on text."];
  RFC9741 -> rev_cites;
}
