digraph Flow {
  rankdir=LR;
  splines=true;
  concentrate=true;   // merge parallel edges / reduce clutter
  nodesep=0.25;       // horizontal/vertical separation between nodes
  ranksep=0.35;       // separation between ranks (columns in LR)
  RFC8472 [label="RFC8472
Transport Layer Security (TLS) Extension
for Token Binding Protocol Negotiation
2018", shape=ellipse, fillcolor="#e8f0ff", tooltip="This document specifies a Transport Layer Security (TLS) extension for the negotiation of Token Binding protocol version and key parameters.  Negotiation of Token Binding in TLS 1.3 and later versions is beyond the scope of this document.", style=filled, fillcolor=green]; 

  obs_by [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  obs_by -> RFC8472;

  obs [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  RFC8472 -> obs;

  updates [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  RFC8472 -> updates;

  updated_by [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  updated_by -> RFC8472;

  cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  RFC8472 -> cites;
  RFC8471 [label="RFC8471
The Token Binding Protocol Version 1.0
2018", shape=ellipse, URL="RFC8471.html", target="_top", tooltip="This document specifies version 1.0 of the Token Binding protocol.  The Token Binding protocol allows client/server applications to create long-lived, uniquely identifiable TLS bindings spanning multiple TLS sessions and connections.  Applications are then enabled to cryptographically bind security tokens to the TLS layer, preventing token export and replay attacks.  To protect privacy, the Token Binding identifiers are only conveyed over TLS and can be reset by the user at any time."];
  cites -> RFC8471;
  RFC5246 [label="RFC5246
The Transport Layer Security (TLS)
Protocol Version 1.2
2008", shape=ellipse, URL="RFC5246.html", target="_top", tooltip="This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS-TRACK]"];
  cites -> RFC5246;
  RFC2119 [label="RFC2119
Key words for use in RFCs to Indicate
Requirement Levels
1997", shape=ellipse, URL="RFC2119.html", target="_top", tooltip="In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements."];
  cites -> RFC2119;
  RFC8174 [label="RFC8174
Ambiguity of Uppercase vs Lowercase in
RFC 2119 Key Words
2017", shape=ellipse, URL="RFC8174.html", target="_top", tooltip="RFC 2119 specifies common key words that may be used in protocol specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings."];
  cites -> RFC8174;
  RFC7627 [label="RFC7627
Transport Layer Security (TLS) Session
Hash and Extended Master Secret
Extension
2015", shape=ellipse, URL="RFC7627.html", target="_top", tooltip="The Transport Layer Security (TLS) master secret is not cryptographically bound to important session parameters such as the server certificate.  Consequently, it is possible for an active attacker to set up two sessions, one with a client and another with a server, such that the master secrets on the two sessions are the same.  Thereafter, any mechanism that relies on the master secret for authentication, including session resumption, becomes vulnerable to a man-in-the-middle attack, where the attacker can simply forward messages back and forth between the client and server.  This specification defines a TLS extension that contextually binds the master secret to a log of the full handshake that computes it, thus preventing such attacks."];
  cites -> RFC7627;
  RFC5746 [label="RFC5746
Transport Layer Security (TLS)
Renegotiation Indication Extension
2010", shape=ellipse, URL="RFC5746.html", target="_top", tooltip="Secure Socket Layer (SSL) and Transport Layer Security (TLS) renegotiation are vulnerable to an attack in which the attacker forms a TLS connection with the target server, injects content of his choice, and then splices in a new TLS connection from a client.  The server treats the client's initial TLS handshake as a renegotiation and thus believes that the initial data transmitted by the attacker is from the same entity as the subsequent client data.  This specification defines a TLS extension to cryptographically tie renegotiations to the TLS connections they are being performed over, thus preventing this attack. [STANDARDS-TRACK]"];
  cites -> RFC5746;
  RFC5705 [label="RFC5705
Keying Material Exporters for Transport
Layer Security (TLS)
2010", shape=ellipse, URL="RFC5705.html", target="_top", tooltip="A number of protocols wish to leverage Transport Layer Security (TLS) to perform key establishment but then use some of the keying material for their own purposes.  This document describes a general mechanism for allowing that. [STANDARDS-TRACK]"];
  cites -> RFC5705;

  rev_cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  rev_cites -> RFC8472;
  RFC8471 [label="RFC8471
The Token Binding Protocol Version 1.0
2018", shape=ellipse, URL="RFC8471.html", target="_top", tooltip="This document specifies version 1.0 of the Token Binding protocol.  The Token Binding protocol allows client/server applications to create long-lived, uniquely identifiable TLS bindings spanning multiple TLS sessions and connections.  Applications are then enabled to cryptographically bind security tokens to the TLS layer, preventing token export and replay attacks.  To protect privacy, the Token Binding identifiers are only conveyed over TLS and can be reset by the user at any time."];
  RFC8471 -> rev_cites;
  RFC8473 [label="RFC8473
Token Binding over HTTP
2018", shape=ellipse, URL="RFC8473.html", target="_top", tooltip="This document describes a collection of mechanisms that allow HTTP servers to cryptographically bind security tokens (such as cookies and OAuth tokens) to TLS connections. We describe both first-party and federated scenarios. In a first- party scenario, an HTTP server is able to cryptographically bind the security tokens that it issues to a client -- and that the client subsequently returns to the server -- to the TLS connection between the client and the server. Such bound security tokens are protected from misuse, since the server can generally detect if they are replayed inappropriately, e.g., over other TLS connections. Federated Token Bindings, on the other hand, allow servers to cryptographically bind security tokens to a TLS connection that the client has with a different server than the one issuing the token. This document is a companion document to The Token Binding Protocol Version 1.0 (RFC 8471)."];
  RFC8473 -> rev_cites;
  RFC8963 [label="RFC8963
Evaluation of a Sample of RFCs Produced
in 2018
2021", shape=ellipse, URL="RFC8963.html", target="_top", tooltip="This document presents the author's effort to understand the delays involved in publishing an idea in the IETF or through the Independent Stream, from the first individual draft to the publication of the RFC. We analyze a set of randomly chosen RFCs approved in 2018, looking for history and delays. We also use two randomly chosen sets of RFCs published in 2008 and 1998 for comparing delays seen in 2018 to those observed 10 or 20 years ago. The average RFC in the 2018 sample was produced in 3 years and 4 months, of which 2 years and 10 months were spent in the working group, 3 to 4 months for IETF consensus and IESG review, and 3 to 4 months in RFC production. The main variation in RFC production delays comes from the AUTH48 phase. We also measure the number of citations of the chosen RFC using Semantic Scholar, and compare citation counts with what we know about deployment. We show that citation counts indicate academic interest, but correlate only loosely with deployment or usage of the specifications. Counting web references could complement that."];
  RFC8963 -> rev_cites;
  RFC9761 [label="RFC9761
Manufacturer Usage Description (MUD) for
TLS and DTLS Profiles for Internet of
Things (IoT) Devices
2025", shape=ellipse, URL="RFC9761.html", target="_top", tooltip="This memo extends the Manufacturer Usage Description (MUD) specification to allow manufacturers to define TLS and DTLS profile parameters.  This allows a network security service to identify unexpected (D)TLS usage, which can indicate the presence of unauthorized software, malware, or security policy-violating traffic on an endpoint."];
  RFC9761 -> rev_cites;
}
