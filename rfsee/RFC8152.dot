digraph Flow {
  rankdir=LR;
  splines=true;
  concentrate=true;   // merge parallel edges / reduce clutter
  nodesep=0.25;       // horizontal/vertical separation between nodes
  ranksep=0.35;       // separation between ranks (columns in LR)
  RFC8152 [label="RFC8152
CBOR Object Signing and Encryption
(COSE)
2017", shape=ellipse, fillcolor="#e8f0ff", tooltip="Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size.  There is a need for the ability to have basic security services defined for this data format.  This document defines the CBOR Object Signing and Encryption (COSE) protocol.  This specification describes how to create and process signatures, message authentication codes, and encryption using CBOR for serialization.  This specification additionally describes how to represent cryptographic keys using CBOR.", style=filled, fillcolor=green]; 

  obs_by [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  obs_by -> RFC8152;
  RFC9052 [label="RFC9052
CBOR Object Signing and Encryption
(COSE): Structures and Process
2022", shape=ellipse, URL="RFC9052.html", target="_top", tooltip="Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. There is a need to be able to define basic security services for this data format. This document defines the CBOR Object Signing and Encryption (COSE) protocol. This specification describes how to create and process signatures, message authentication codes, and encryption using CBOR for serialization. This specification additionally describes how to represent cryptographic keys using CBOR. This document, along with RFC 9053, obsoletes RFC 8152."];
  RFC9052 -> obs_by;
  RFC9053 [label="RFC9053
CBOR Object Signing and Encryption
(COSE): Initial Algorithms
2022", shape=ellipse, URL="RFC9053.html", target="_top", tooltip="Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. There is a need to be able to define basic security services for this data format. This document defines a set of algorithms that can be used with the CBOR Object Signing and Encryption (COSE) protocol (RFC 9052). This document, along with RFC 9052, obsoletes RFC 8152."];
  RFC9053 -> obs_by;

  obs [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  RFC8152 -> obs;

  updates [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  RFC8152 -> updates;

  updated_by [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  updated_by -> RFC8152;

  cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  RFC8152 -> cites;
  RFC7049 [label="RFC7049
Concise Binary Object Representation
(CBOR)
2013", shape=ellipse, URL="RFC7049.html", target="_top", tooltip="The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation.  These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack."];
  cites -> RFC7049;
  RFC7159 [label="RFC7159
The JavaScript Object Notation (JSON)
Data Interchange Format
2014", shape=ellipse, URL="RFC7159.html", target="_top", tooltip="JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format. It was derived from the ECMAScript Programming Language Standard. JSON defines a small set of formatting rules for the portable representation of structured data. This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance."];
  cites -> RFC7159;
  RFC7515 [label="RFC7515
JSON Web Signature (JWS)
2015", shape=ellipse, URL="RFC7515.html", target="_top", tooltip="JSON Web Signature (JWS) represents content secured with digital signatures or Message Authentication Codes (MACs) using JSON-based data structures.  Cryptographic algorithms and identifiers for use with this specification are described in the separate JSON Web Algorithms (JWA) specification and an IANA registry defined by that specification.  Related encryption capabilities are described in the separate JSON Web Encryption (JWE) specification."];
  cites -> RFC7515;
  RFC7516 [label="RFC7516
JSON Web Encryption (JWE)
2015", shape=ellipse, URL="RFC7516.html", target="_top", tooltip="JSON Web Encryption (JWE) represents encrypted content using JSON-based data structures.  Cryptographic algorithms and identifiers for use with this specification are described in the separate JSON Web Algorithms (JWA) specification and IANA registries defined by that specification.  Related digital signature and Message Authentication Code (MAC) capabilities are described in the separate JSON Web Signature (JWS) specification."];
  cites -> RFC7516;
  RFC7517 [label="RFC7517
JSON Web Key (JWK)
2015", shape=ellipse, URL="RFC7517.html", target="_top", tooltip="A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key.  This specification also defines a JWK Set JSON data structure that represents a set of JWKs.  Cryptographic algorithms and identifiers for use with this specification are described in the separate JSON Web Algorithms (JWA) specification and IANA registries established by that specification."];
  cites -> RFC7517;
  RFC7518 [label="RFC7518
JSON Web Algorithms (JWA)
2015", shape=ellipse, URL="RFC7518.html", target="_top", tooltip="This specification registers cryptographic algorithms and identifiers to be used with the JSON Web Signature (JWS), JSON Web Encryption (JWE), and JSON Web Key (JWK) specifications.  It defines several IANA registries for these identifiers."];
  cites -> RFC7518;
  RFC2119 [label="RFC2119
Key words for use in RFCs to Indicate
Requirement Levels
1997", shape=ellipse, URL="RFC2119.html", target="_top", tooltip="In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements."];
  cites -> RFC2119;
  RFC8174 [label="RFC8174
Ambiguity of Uppercase vs Lowercase in
RFC 2119 Key Words
2017", shape=ellipse, URL="RFC8174.html", target="_top", tooltip="RFC 2119 specifies common key words that may be used in protocol specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings."];
  cites -> RFC8174;
  RFC7252 [label="RFC7252
The Constrained Application Protocol
(CoAP)
2014", shape=ellipse, URL="RFC7252.html", target="_top", tooltip="The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use with constrained nodes and constrained (e.g., low-power, lossy) networks. The nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while constrained networks such as IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs) often have high packet error rates and a typical throughput of 10s of kbit/s. The protocol is designed for machine- to-machine (M2M) applications such as smart energy and building automation. CoAP provides a request/response interaction model between application endpoints, supports built-in discovery of services and resources, and includes key concepts of the Web such as URIs and Internet media types. CoAP is designed to easily interface with HTTP for integration with the Web while meeting specialized requirements such as multicast support, very low overhead, and simplicity for constrained environments."];
  cites -> RFC7252;
  RFC5116 [label="RFC5116
An Interface and Algorithms for
Authenticated Encryption
2008", shape=ellipse, URL="RFC5116.html", target="_top", tooltip="This document defines algorithms for Authenticated Encryption with Associated Data (AEAD), and defines a uniform interface and a registry for such algorithms.  The interface and registry can be used as an application-independent set of cryptoalgorithm suites.  This approach provides advantages in efficiency and security, and promotes the reuse of crypto implementations. [STANDARDS-TRACK]"];
  cites -> RFC5116;
  RFC6838 [label="RFC6838
Media Type Specifications and
Registration Procedures
2013", shape=ellipse, URL="RFC6838.html", target="_top", tooltip="This document defines procedures for the specification and registration of media types for use in HTTP, MIME, and other Internet protocols.  This memo documents an Internet Best Current Practice."];
  cites -> RFC6838;
  RFC8032 [label="RFC8032
Edwards-Curve Digital Signature
Algorithm (EdDSA)
2017", shape=ellipse, URL="RFC8032.html", target="_top", tooltip="This document describes elliptic curve signature scheme Edwards-curve Digital Signature Algorithm (EdDSA).  The algorithm is instantiated with recommended parameters for the edwards25519 and edwards448 curves.  An example implementation and test vectors are provided."];
  cites -> RFC8032;
  RFC5752 [label="RFC5752
Multiple Signatures in Cryptographic
Message Syntax (CMS)
2010", shape=ellipse, URL="RFC5752.html", target="_top", tooltip="Cryptographic Message Syntax (CMS) SignedData includes the SignerInfo structure to convey per-signer information.  SignedData supports multiple signers and multiple signature algorithms per signer with multiple SignerInfo structures.  If a signer attaches more than one SignerInfo, there are concerns that an attacker could perform a downgrade attack by removing the SignerInfo(s) with the \'strong' algorithm(s).  This document defines the multiple-signatures attribute, its generation rules, and its processing rules to allow signers to convey multiple SignerInfo objects while protecting against downgrade attacks.  Additionally, this attribute may assist during periods of algorithm migration. [STANDARDS-TRACK]"];
  cites -> RFC5752;
  RFC5652 [label="RFC5652
Cryptographic Message Syntax (CMS)
2009", shape=ellipse, URL="RFC5652.html", target="_top", tooltip="This document describes the Cryptographic Message Syntax (CMS).  This syntax is used to digitally sign, digest, authenticate, or encrypt arbitrary message content. [STANDARDS-TRACK]"];
  cites -> RFC5652;
  RFC6979 [label="RFC6979
Deterministic Usage of the Digital
Signature Algorithm (DSA) and Elliptic
Curve Digital Signature Algorithm
(ECDSA)
2013", shape=ellipse, URL="RFC6979.html", target="_top", tooltip="This document defines a deterministic digital signature generation procedure.  Such signatures are compatible with standard Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA) digital signatures and can be processed with unmodified verifiers, which need not be aware of the procedure described therein.  Deterministic signatures retain the cryptographic security features associated with digital signatures but can be more easily implemented in various environments, since they do not need access to a source of high-quality randomness."];
  cites -> RFC6979;
  RFC5480 [label="RFC5480
Elliptic Curve Cryptography Subject
Public Key Information
2009", shape=ellipse, URL="RFC5480.html", target="_top", tooltip="This document specifies the syntax and semantics for the Subject Public Key Information field in certificates that support Elliptic Curve Cryptography.  This document updates Sections 2.3.5 and 5, and the ASN.1 module of Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile, RFC 3279. [STANDARDS-TRACK]"];
  cites -> RFC5480;
  RFC8017 [label="RFC8017
PKCS #1: RSA Cryptography Specifications
Version 2.2
2016", shape=ellipse, URL="RFC8017.html", target="_top", tooltip="This document provides recommendations for the implementation of public-key cryptography based on the RSA algorithm, covering cryptographic primitives, encryption schemes, signature schemes with appendix, and ASN.1 syntax for representing keys and for identifying the schemes. This document represents a republication of PKCS #1 v2.2 from RSA Laboratories' Public-Key Cryptography Standards (PKCS) series. By publishing this RFC, change control is transferred to the IETF. This document also obsoletes RFC 3447."];
  cites -> RFC8017;
  RFC2104 [label="RFC2104
HMAC: Keyed-Hashing for Message
Authentication
1997", shape=ellipse, URL="RFC2104.html", target="_top", tooltip="This document describes HMAC, a mechanism for message authentication using cryptographic hash functions.  HMAC can be used with any iterative cryptographic hash function, e.g., MD5, SHA-1, in combination with a secret shared key.  The cryptographic strength of HMAC depends on the properties of the underlying hash function.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind"];
  cites -> RFC2104;
  RFC4231 [label="RFC4231
Identifiers and Test Vectors for HMAC-
SHA-224, HMAC-SHA-256, HMAC-SHA-384, and
HMAC-SHA-512
2005", shape=ellipse, URL="RFC4231.html", target="_top", tooltip="This document provides test vectors for the HMAC-SHA-224, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512 message authentication schemes.  It also provides ASN.1 object identifiers and Uniform Resource Identifiers (URIs) to identify use of these schemes in protocols.  The test vectors provided in this document may be used for conformance testing. [STANDARDS-TRACK]"];
  cites -> RFC4231;
  RFC6151 [label="RFC6151
Updated Security Considerations for the
MD5 Message-Digest and the HMAC-MD5
Algorithms
2011", shape=ellipse, URL="RFC6151.html", target="_top", tooltip="This document updates the security considerations for the MD5 message digest algorithm.  It also updates the security considerations for HMAC-MD5.  This document is not an Internet Standards Track specification; it is published for informational purposes."];
  cites -> RFC6151;
  RFC4493 [label="RFC4493
The AES-CMAC Algorithm
2006", shape=ellipse, URL="RFC4493.html", target="_top", tooltip="The National Institute of Standards and Technology (NIST) has recently specified the Cipher-based Message Authentication Code (CMAC), which is equivalent to the One-Key CBC MAC1 (OMAC1) submitted by Iwata and Kurosawa.  This memo specifies an authentication algorithm based on CMAC with the 128-bit Advanced Encryption Standard (AES).  This new authentication algorithm is named AES-CMAC.  The purpose of this document is to make the AES-CMAC algorithm conveniently available to the Internet Community.  This memo provides information for the Internet community."];
  cites -> RFC4493;
  RFC3610 [label="RFC3610
Counter with CBC-MAC (CCM)
2003", shape=ellipse, URL="RFC3610.html", target="_top", tooltip="Counter with CBC-MAC (CCM) is a generic authenticated encryption block cipher mode.  CCM is defined for use with 128-bit block ciphers, such as the Advanced Encryption Standard (AES)."];
  cites -> RFC3610;
  RFC7539 [label="RFC7539
ChaCha20 and Poly1305 for IETF Protocols
2015", shape=ellipse, URL="RFC7539.html", target="_top", tooltip="This document defines the ChaCha20 stream cipher as well as the use of the Poly1305 authenticator, both as stand-alone algorithms and as a combined mode, or Authenticated Encryption with Associated Data (AEAD) algorithm. This document does not introduce any new crypto, but is meant to serve as a stable reference and an implementation guide. It is a product of the Crypto Forum Research Group (CFRG)."];
  cites -> RFC7539;
  RFC8018 [label="RFC8018
PKCS #5: Password-Based Cryptography
Specification Version 2.1
2017", shape=ellipse, URL="RFC8018.html", target="_top", tooltip="This document provides recommendations for the implementation of password-based cryptography, covering key derivation functions, encryption schemes, message authentication schemes, and ASN.1 syntax identifying the techniques. This document represents a republication of PKCS #5 v2.1 from RSA Laboratories' Public-Key Cryptography Standards (PKCS) series. By publishing this RFC, change control is transferred to the IETF. This document also obsoletes RFC 2898."];
  cites -> RFC8018;
  RFC5869 [label="RFC5869
HMAC-based Extract-and-Expand Key
Derivation Function (HKDF)
2010", shape=ellipse, URL="RFC5869.html", target="_top", tooltip="This document specifies a simple Hashed Message Authentication Code (HMAC)-based key derivation function (HKDF), which can be used as a building block in various protocols and applications.  The key derivation function (KDF) is intended to support a wide range of applications and requirements, and is conservative in its use of cryptographic hash functions.  This document is not an Internet Standards Track specification; it is published for informational purposes."];
  cites -> RFC5869;
  RFC3394 [label="RFC3394
Advanced Encryption Standard (AES) Key
Wrap Algorithm
2002", shape=ellipse, URL="RFC3394.html", target="_top", tooltip="None"];
  cites -> RFC3394;
  RFC4949 [label="RFC4949
Internet Security Glossary, Version 2
2007", shape=ellipse, URL="RFC4949.html", target="_top", tooltip="This Glossary provides definitions, abbreviations, and explanations of terminology for information system security.  The 334 pages of entries offer recommendations to improve the comprehensibility of written material that is generated in the Internet Standards Process (RFC 2026).  The recommendations follow the principles that such writing should (a) use the same term or definition whenever the same concept is mentioned; (b) use terms in their plainest, dictionary sense; (c) use terms that are already well-established in open publications; and (d) avoid terms that either favor a particular vendor or favor a particular technology or mechanism over other, competing techniques that already exist or could be developed.  This memo provides information for the Internet community."];
  cites -> RFC4949;
  RFC6090 [label="RFC6090
Fundamental Elliptic Curve Cryptography
Algorithms
2011", shape=ellipse, URL="RFC6090.html", target="_top", tooltip="This note describes the fundamental algorithms of Elliptic Curve Cryptography (ECC) as they were defined in some seminal references from 1994 and earlier.  These descriptions may be useful for implementing the fundamental algorithms without using any of the specialized methods that were developed in following years.  Only elliptic curves defined over fields of characteristic greater than three are in scope; these curves are those used in Suite B.  This document is not an Internet Standards Track specification; it is published for informational purposes."];
  cites -> RFC6090;
  RFC7748 [label="RFC7748
Elliptic Curves for Security
2016", shape=ellipse, URL="RFC7748.html", target="_top", tooltip="This memo specifies two elliptic curves over prime fields that offer a high level of practical security in cryptographic applications, including Transport Layer Security (TLS).  These curves are intended to operate at the ~128-bit and ~224-bit security level, respectively, and are generated deterministically based on a list of required properties."];
  cites -> RFC7748;
  RFC5751 [label="RFC5751
Secure/Multipurpose Internet Mail
Extensions (S/MIME) Version 3.2 Message
Specification
2010", shape=ellipse, URL="RFC5751.html", target="_top", tooltip="This document defines Secure/Multipurpose Internet Mail Extensions (S/MIME) version 3.2.  S/MIME provides a consistent way to send and receive secure MIME data.  Digital signatures provide authentication, message integrity, and non-repudiation with proof of origin.  Encryption provides data confidentiality.  Compression can be used to reduce data size.  This document obsoletes RFC 3851. [STANDARDS-TRACK]"];
  cites -> RFC5751;
  RFC4262 [label="RFC4262
X.509 Certificate Extension for
Secure/Multipurpose Internet Mail
Extensions (S/MIME) Capabilities
2005", shape=ellipse, URL="RFC4262.html", target="_top", tooltip="This document defines a certificate extension for inclusion of Secure/Multipurpose Internet Mail Extensions (S/MIME) Capabilities in X.509 public key certificates, as defined by RFC 3280.  This certificate extension provides an optional method to indicate the cryptographic capabilities of an entity as a complement to the S/MIME Capabilities signed attribute in S/MIME messages according to RFC 3851. [STANDARDS-TRACK]"];
  cites -> RFC4262;
  RFC2633 [label="RFC2633
S/MIME Version 3 Message Specification
1999", shape=ellipse, URL="RFC2633.html", target="_top", tooltip="This document describes a protocol for adding cryptographic signature and encryption services to MIME data. [STANDARDS-TRACK]"];
  cites -> RFC2633;
  RFC8126 [label="RFC8126
Guidelines for Writing an IANA
Considerations Section in RFCs
2017", shape=ellipse, URL="RFC8126.html", target="_top", tooltip="Many protocols make use of points of extensibility that use constants to identify various protocol parameters. To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper. For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA). To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed. This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry. This is the third edition of this document; it obsoletes RFC 5226."];
  cites -> RFC8126;
  RFC5990 [label="RFC5990
Use of the RSA-KEM Key Transport
Algorithm in the Cryptographic Message
Syntax (CMS)
2010", shape=ellipse, URL="RFC5990.html", target="_top", tooltip="The RSA-KEM Key Transport Algorithm is a one-pass (store-and-forward) mechanism for transporting keying data to a recipient using the recipient's RSA public key. (KEM stands for key encapsulation mechanism.) This document specifies the conventions for using the RSA-KEM Key Transport Algorithm with the Cryptographic Message Syntax (CMS).  The ASN.1 syntax is aligned with an expected forthcoming change to American National Standard (ANS) X9.44."];
  cites -> RFC5990;

  rev_cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  rev_cites -> RFC8152;
  RFC8230 [label="RFC8230
Using RSA Algorithms with CBOR Object
Signing and Encryption (COSE) Messages
2017", shape=ellipse, URL="RFC8230.html", target="_top", tooltip="The CBOR Object Signing and Encryption (COSE) specification defines cryptographic message encodings using Concise Binary Object Representation (CBOR).  This specification defines algorithm encodings and representations enabling RSA algorithms to be used for COSE messages.  Encodings are specified for the use of RSA Probabilistic Signature Scheme (RSASSA-PSS) signatures, RSA Encryption Scheme - Optimal Asymmetric Encryption Padding (RSAES-OAEP) encryption, and RSA keys."];
  RFC8230 -> rev_cites;
  RFC8387 [label="RFC8387
Practical Considerations and
Implementation Experiences in Securing
Smart Object Networks
2018", shape=ellipse, URL="RFC8387.html", target="_top", tooltip="This memo describes challenges associated with securing resource- constrained smart object devices.  The memo describes a possible deployment model where resource-constrained devices sign message objects, discusses the availability of cryptographic libraries for resource-constrained devices, and presents some preliminary experiences with those libraries for message signing on resource- constrained devices.  Lastly, the memo discusses trade-offs involving different types of security approaches."];
  RFC8387 -> rev_cites;
  RFC8392 [label="RFC8392
CBOR Web Token (CWT)
2018", shape=ellipse, URL="RFC8392.html", target="_top", tooltip="CBOR Web Token (CWT) is a compact means of representing claims to be transferred between two parties.  The claims in a CWT are encoded in the Concise Binary Object Representation (CBOR), and CBOR Object Signing and Encryption (COSE) is used for added application-layer security protection.  A claim is a piece of information asserted about a subject and is represented as a name/value pair consisting of a claim name and a claim value.  CWT is derived from JSON Web Token (JWT) but uses CBOR rather than JSON."];
  RFC8392 -> rev_cites;
  RFC8576 [label="RFC8576
Internet of Things (IoT) Security: State
of the Art and Challenges
2019", shape=ellipse, URL="RFC8576.html", target="_top", tooltip="The Internet of Things (IoT) concept refers to the usage of standard Internet protocols to allow for human-to-thing and thing-to-thing communication. The security needs for IoT systems are well recognized, and many standardization steps to provide security have been taken -- for example, the specification of the Constrained Application Protocol (CoAP) secured with Datagram Transport Layer Security (DTLS). However, security challenges still exist, not only because there are some use cases that lack a suitable solution, but also because many IoT devices and systems have been designed and deployed with very limited security capabilities. In this document, we first discuss the various stages in the lifecycle of a thing. Next, we document the security threats to a thing and the challenges that one might face to protect against these threats. Lastly, we discuss the next steps needed to facilitate the deployment of secure IoT systems. This document can be used by implementers and authors of IoT specifications as a reference for details about security considerations while documenting their specific security challenges, threat models, and mitigations. This document is a product of the IRTF Thing-to-Thing Research Group (T2TRG)."];
  RFC8576 -> rev_cites;
  RFC8610 [label="RFC8610
Concise Data Definition Language (CDDL):
A Notational Convention to Express
Concise Binary Object Representation
(CBOR) and JSON Data Structures
2019", shape=ellipse, URL="RFC8610.html", target="_top", tooltip="This document proposes a notational convention to express Concise Binary Object Representation (CBOR) data structures (RFC 7049).  Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON."];
  RFC8610 -> rev_cites;
  RFC8613 [label="RFC8613
Object Security for Constrained RESTful
Environments (OSCORE)
2019", shape=ellipse, URL="RFC8613.html", target="_top", tooltip="This document defines Object Security for Constrained RESTful Environments (OSCORE), a method for application-layer protection of the Constrained Application Protocol (CoAP), using CBOR Object Signing and Encryption (COSE). OSCORE provides end-to-end protection between endpoints communicating using CoAP or CoAP-mappable HTTP. OSCORE is designed for constrained nodes and networks supporting a range of proxy operations, including translation between different transport protocols. Although an optional functionality of CoAP, OSCORE alters CoAP options processing and IANA registration. Therefore, this document updates RFC 7252."];
  RFC8613 -> rev_cites;
  RFC8742 [label="RFC8742
Concise Binary Object Representation
(CBOR) Sequences
2020", shape=ellipse, URL="RFC8742.html", target="_top", tooltip="This document describes the Concise Binary Object Representation (CBOR) Sequence format and associated media type application/cbor-seq. A CBOR Sequence consists of any number of encoded CBOR data items, simply concatenated in sequence. Structured syntax suffixes for media types allow other media types to build on them and make it explicit that they are built on an existing media type as their foundation. This specification defines and registers +cbor-seq as a structured syntax suffix for CBOR Sequences."];
  RFC8742 -> rev_cites;
  RFC8747 [label="RFC8747
Proof-of-Possession Key Semantics for
CBOR Web Tokens (CWTs)
2020", shape=ellipse, URL="RFC8747.html", target="_top", tooltip="This specification describes how to declare in a CBOR Web Token (CWT) (which is defined by RFC 8392) that the presenter of the CWT possesses a particular proof-of-possession key.  Being able to prove possession of a key is also sometimes described as being the holder-of-key.  This specification provides equivalent functionality to Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs) (RFC 7800) but using Concise Binary Object Representation (CBOR) and CWTs rather than JavaScript Object Notation (JSON) and JSON Web Tokens (JWTs)."];
  RFC8747 -> rev_cites;
  RFC8778 [label="RFC8778
Use of the HSS/LMS Hash-Based Signature
Algorithm with CBOR Object Signing and
Encryption (COSE)
2020", shape=ellipse, URL="RFC8778.html", target="_top", tooltip="This document specifies the conventions for using the Hierarchical Signature System (HSS) / Leighton-Micali Signature (LMS) hash-based signature algorithm with the CBOR Object Signing and Encryption (COSE) syntax.  The HSS/LMS algorithm is one form of hash-based digital signature; it is described in RFC 8554."];
  RFC8778 -> rev_cites;
  RFC8812 [label="RFC8812
CBOR Object Signing and Encryption
(COSE) and JSON Object Signing and
Encryption (JOSE) Registrations for Web
Authentication (WebAuthn) Algorithms
2020", shape=ellipse, URL="RFC8812.html", target="_top", tooltip="The W3C Web Authentication (WebAuthn) specification and the FIDO Alliance FIDO2 Client to Authenticator Protocol (CTAP) specification use CBOR Object Signing and Encryption (COSE) algorithm identifiers.  This specification registers the following algorithms (which are used by WebAuthn and CTAP implementations) in the IANA COSE Algorithms registry: RSASSA-PKCS1-v1_5 using SHA-256, SHA-384, SHA-512, and SHA-1; and Elliptic Curve Digital Signature Algorithm (ECDSA) using the secp256k1 curve and SHA-256.  It registers the secp256k1 elliptic curve in the IANA COSE Elliptic Curves registry.  Also, for use with JSON Object Signing and Encryption (JOSE), it registers the algorithm ECDSA using the secp256k1 curve and SHA-256 in the IANA JSON Web Signature and Encryption Algorithms registry and the secp256k1 elliptic curve in the IANA JSON Web Key Elliptic Curve registry."];
  RFC8812 -> rev_cites;
  RFC9021 [label="RFC9021
Use of the Walnut Digital Signature
Algorithm with CBOR Object Signing and
Encryption (COSE)
2021", shape=ellipse, URL="RFC9021.html", target="_top", tooltip="This document specifies the conventions for using the Walnut Digital Signature Algorithm (WalnutDSA) for digital signatures with the CBOR Object Signing and Encryption (COSE) syntax. WalnutDSA is a lightweight, quantum-resistant signature scheme based on Group Theoretic Cryptography with implementation and computational efficiency of signature verification in constrained environments, even on 8- and 16-bit platforms. The goal of this publication is to document a way to use the lightweight, quantum-resistant WalnutDSA signature algorithm in COSE in a way that would allow multiple developers to build compatible implementations. As of this publication, the security properties of WalnutDSA have not been evaluated by the IETF and its use has not been endorsed by the IETF. WalnutDSA and the Walnut Digital Signature Algorithm are trademarks of Veridify Security Inc."];
  RFC9021 -> rev_cites;
  RFC9031 [label="RFC9031
Constrained Join Protocol (CoJP) for
6TiSCH
2021", shape=ellipse, URL="RFC9031.html", target="_top", tooltip="This document describes the minimal framework required for a new device, called a pledge, to securely join a 6TiSCH (IPv6 over the Time-Slotted Channel Hopping mode of IEEE 802.15.4) network.  The framework requires that the pledge and the JRC (Join Registrar/Coordinator, a central entity), share a symmetric key.  How this key is provisioned is out of scope of this document.  Through a single CoAP (Constrained Application Protocol) request-response exchange secured by OSCORE (Object Security for Constrained RESTful Environments), the pledge requests admission into the network, and the JRC configures it with link-layer keying material and other parameters.  The JRC may at any time update the parameters through another request-response exchange secured by OSCORE.  This specification defines the Constrained Join Protocol and its CBOR (Concise Binary Object Representation) data structures, and it describes how to configure the rest of the 6TiSCH communication stack for this join process to occur in a secure manner.  Additional security mechanisms may be added on top of this minimal framework."];
  RFC9031 -> rev_cites;
  RFC9052 [label="RFC9052
CBOR Object Signing and Encryption
(COSE): Structures and Process
2022", shape=ellipse, URL="RFC9052.html", target="_top", tooltip="Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. There is a need to be able to define basic security services for this data format. This document defines the CBOR Object Signing and Encryption (COSE) protocol. This specification describes how to create and process signatures, message authentication codes, and encryption using CBOR for serialization. This specification additionally describes how to represent cryptographic keys using CBOR. This document, along with RFC 9053, obsoletes RFC 8152."];
  RFC9052 -> rev_cites;
  RFC9053 [label="RFC9053
CBOR Object Signing and Encryption
(COSE): Initial Algorithms
2022", shape=ellipse, URL="RFC9053.html", target="_top", tooltip="Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. There is a need to be able to define basic security services for this data format. This document defines a set of algorithms that can be used with the CBOR Object Signing and Encryption (COSE) protocol (RFC 9052). This document, along with RFC 9052, obsoletes RFC 8152."];
  RFC9053 -> rev_cites;
  RFC9173 [label="RFC9173
Default Security Contexts for Bundle
Protocol Security (BPSec)
2022", shape=ellipse, URL="RFC9173.html", target="_top", tooltip="This document defines default integrity and confidentiality security contexts that can be used with Bundle Protocol Security (BPSec) implementations.  These security contexts are intended to be used both for testing the interoperability of BPSec implementations and for providing basic security operations when no other security contexts are defined or otherwise required for a network."];
  RFC9173 -> rev_cites;
  RFC9200 [label="RFC9200
Authentication and Authorization for
Constrained Environments Using the OAuth
2.0 Framework (ACE-OAuth)
2022", shape=ellipse, URL="RFC9200.html", target="_top", tooltip="This specification defines a framework for authentication and authorization in Internet of Things (IoT) environments called ACE-OAuth.  The framework is based on a set of building blocks including OAuth 2.0 and the Constrained Application Protocol (CoAP), thus transforming a well-known and widely used authorization solution into a form suitable for IoT devices.  Existing specifications are used where possible, but extensions are added and profiles are defined to better serve the IoT use cases."];
  RFC9200 -> rev_cites;
  RFC9201 [label="RFC9201
Additional OAuth Parameters for
Authentication and Authorization for
Constrained Environments (ACE)
2022", shape=ellipse, URL="RFC9201.html", target="_top", tooltip="This specification defines new parameters and encodings for the OAuth 2.0 token and introspection endpoints when used with the framework for Authentication and Authorization for Constrained Environments (ACE).  These are used to express the proof-of-possession (PoP) key the client wishes to use, the PoP key that the authorization server has selected, and the PoP key the resource server uses to authenticate to the client."];
  RFC9201 -> rev_cites;
  RFC9202 [label="RFC9202
Datagram Transport Layer Security (DTLS)
Profile for Authentication and
Authorization for Constrained
Environments (ACE)
2022", shape=ellipse, URL="RFC9202.html", target="_top", tooltip="This specification defines a profile of the Authentication and Authorization for Constrained Environments (ACE) framework that allows constrained servers to delegate client authentication and authorization.  The protocol relies on DTLS version 1.2 or later for communication security between entities in a constrained network using either raw public keys or pre-shared keys.  A resource-constrained server can use this protocol to delegate management of authorization information to a trusted host with less-severe limitations regarding processing power and memory."];
  RFC9202 -> rev_cites;
  RFC9277 [label="RFC9277
On Stable Storage for Items in Concise
Binary Object Representation (CBOR)
2022", shape=ellipse, URL="RFC9277.html", target="_top", tooltip="This document defines a stored (file) format for Concise Binary Object Representation (CBOR) data items that is friendly to common systems that recognize file types, such as the Unix file(1) command."];
  RFC9277 -> rev_cites;
  RFC9338 [label="RFC9338
CBOR Object Signing and Encryption
(COSE): Countersignatures
2022", shape=ellipse, URL="RFC9338.html", target="_top", tooltip="Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size.  CBOR Object Signing and Encryption (COSE) defines a set of security services for CBOR.  This document defines a countersignature algorithm along with the needed header parameters and CBOR tags for COSE.  This document updates RFC 9052."];
  RFC9338 -> rev_cites;
  RFC9360 [label="RFC9360
CBOR Object Signing and Encryption
(COSE): Header Parameters for Carrying
and Referencing X.509 Certificates
2023", shape=ellipse, URL="RFC9360.html", target="_top", tooltip="The CBOR Object Signing and Encryption (COSE) message structure uses references to keys in general.  For some algorithms, additional properties are defined that carry parameters relating to keys as needed.  The COSE Key structure is used for transporting keys outside of COSE messages.  This document extends the way that keys can be identified and transported by providing attributes that refer to or contain X.509 certificates."];
  RFC9360 -> rev_cites;
  RFC9864 [label="RFC9864
Fully-Specified Algorithms for JSON
Object Signing and Encryption (JOSE) and
CBOR Object Signing and Encryption
(COSE)
2025", shape=ellipse, URL="RFC9864.html", target="_top", tooltip="This specification refers to cryptographic algorithm identifiers that fully specify the cryptographic operations to be performed, including any curve, key derivation function (KDF), and hash functions, as being fully specified. It refers to cryptographic algorithm identifiers that require additional information beyond the algorithm identifier to determine the cryptographic operations to be performed as being polymorphic. This specification creates fully-specified algorithm identifiers for registered JSON Object Signing and Encryption (JOSE) and CBOR Object Signing and Encryption (COSE) polymorphic algorithm identifiers, enabling applications to use only fully-specified algorithm identifiers. It deprecates those polymorphic algorithm identifiers. This specification updates RFCs 7518, 8037, and 9053. It deprecates polymorphic algorithms defined by RFCs 8037 and 9053 and provides fully-specified replacements for them. It adds to the instructions to designated experts in RFCs 7518 and 9053."];
  RFC9864 -> rev_cites;
}
