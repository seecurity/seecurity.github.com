digraph Flow {
  rankdir=LR;
  splines=true;
  concentrate=true;   // merge parallel edges / reduce clutter
  nodesep=0.25;       // horizontal/vertical separation between nodes
  ranksep=0.35;       // separation between ranks (columns in LR)
  RFC9530 [label="RFC9530
Digest Fields
2024", shape=ellipse, fillcolor="#e8f0ff", tooltip="This document defines HTTP fields that support integrity digests. The Content-Digest field can be used for the integrity of HTTP message content. The Repr-Digest field can be used for the integrity of HTTP representations. Want-Content-Digest and Want-Repr-Digest can be used to indicate a sender's interest and preferences for receiving the respective Integrity fields. This document obsoletes RFC 3230 and the Digest and Want-Digest HTTP fields.", style=filled, fillcolor=green]; 

  obs_by [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  obs_by -> RFC9530;

  obs [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  RFC9530 -> obs;
  RFC3230 [label="RFC3230
Instance Digests in HTTP
2002", shape=ellipse, URL="RFC3230.html", target="_top", tooltip="HTTP/1.1 defines a Content-MD5 header that allows a server to include a digest of the response body.  However, this is specifically defined to cover the body of the actual message, not the contents of the full file (which might be quite different, if the response is a Content-Range, or uses a delta encoding).  Also, the Content-MD5 is limited to one specific digest algorithm; other algorithms, such as SHA-1 (Secure Hash Standard), may be more appropriate in some circumstances.  Finally, HTTP/1.1 provides no explicit mechanism by which a client may request a digest.  This document proposes HTTP extensions that solve these problems. [STANDARDS-TRACK]"];
  obs -> RFC3230;

  updates [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  RFC9530 -> updates;

  updated_by [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  updated_by -> RFC9530;

  cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  RFC9530 -> cites;
  RFC3230 [label="RFC3230
Instance Digests in HTTP
2002", shape=ellipse, URL="RFC3230.html", target="_top", tooltip="HTTP/1.1 defines a Content-MD5 header that allows a server to include a digest of the response body.  However, this is specifically defined to cover the body of the actual message, not the contents of the full file (which might be quite different, if the response is a Content-Range, or uses a delta encoding).  Also, the Content-MD5 is limited to one specific digest algorithm; other algorithms, such as SHA-1 (Secure Hash Standard), may be more appropriate in some circumstances.  Finally, HTTP/1.1 provides no explicit mechanism by which a client may request a digest.  This document proposes HTTP extensions that solve these problems. [STANDARDS-TRACK]"];
  cites -> RFC3230;
  RFC2119 [label="RFC2119
Key words for use in RFCs to Indicate
Requirement Levels
1997", shape=ellipse, URL="RFC2119.html", target="_top", tooltip="In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements."];
  cites -> RFC2119;
  RFC8174 [label="RFC8174
Ambiguity of Uppercase vs Lowercase in
RFC 2119 Key Words
2017", shape=ellipse, URL="RFC8174.html", target="_top", tooltip="RFC 2119 specifies common key words that may be used in protocol specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings."];
  cites -> RFC8174;
  RFC5234 [label="RFC5234
Augmented BNF for Syntax Specifications:
ABNF
2008", shape=ellipse, URL="RFC5234.html", target="_top", tooltip="Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF.  It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications. [STANDARDS-TRACK]"];
  cites -> RFC5234;
  RFC7405 [label="RFC7405
Case-Sensitive String Support in ABNF
2014", shape=ellipse, URL="RFC7405.html", target="_top", tooltip="This document extends the base definition of ABNF (Augmented Backus-Naur Form) to include a way to specify US-ASCII string literals that are matched in a case-sensitive manner."];
  cites -> RFC7405;
  RFC8126 [label="RFC8126
Guidelines for Writing an IANA
Considerations Section in RFCs
2017", shape=ellipse, URL="RFC8126.html", target="_top", tooltip="Many protocols make use of points of extensibility that use constants to identify various protocol parameters. To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper. For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA). To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed. This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry. This is the third edition of this document; it obsoletes RFC 5226."];
  cites -> RFC8126;
  RFC8188 [label="RFC8188
Encrypted Content-Encoding for HTTP
2017", shape=ellipse, URL="RFC8188.html", target="_top", tooltip="This memo introduces a content coding for HTTP that allows message payloads to be encrypted."];
  cites -> RFC8188;
  RFC7696 [label="RFC7696
Guidelines for Cryptographic Algorithm
Agility and Selecting Mandatory-to-
Implement Algorithms
2015", shape=ellipse, URL="RFC7696.html", target="_top", tooltip="Many IETF protocols use cryptographic algorithms to provide confidentiality, integrity, authentication, or digital signature.  Communicating peers must support a common set of cryptographic algorithms for these mechanisms to work properly.  This memo provides guidelines to ensure that protocols have the ability to migrate from one mandatory-to-implement algorithm suite to another over time."];
  cites -> RFC7696;
  RFC6211 [label="RFC6211
Cryptographic Message Syntax (CMS)
Algorithm Identifier Protection
Attribute
2011", shape=ellipse, URL="RFC6211.html", target="_top", tooltip="The Cryptographic Message Syntax (CMS), unlike X.509/PKIX certificates, is vulnerable to algorithm substitution attacks.  In an algorithm substitution attack, the attacker changes either the algorithm being used or the parameters of the algorithm in order to change the result of a signature verification process.  In X.509 certificates, the signature algorithm is protected because it is duplicated in the TBSCertificate.signature field with the proviso that the validator is to compare both fields as part of the signature validation process.  This document defines a new attribute that contains a copy of the relevant algorithm identifiers so that they are protected by the signature or authentication process. [STANDARDS-TRACK]"];
  cites -> RFC6211;
  RFC6234 [label="RFC6234
US Secure Hash Algorithms (SHA and SHA-
based HMAC and HKDF)
2011", shape=ellipse, URL="RFC6234.html", target="_top", tooltip="Federal Information Processing Standard, FIPS"];
  cites -> RFC6234;
  RFC4648 [label="RFC4648
The Base16, Base32, and Base64 Data
Encodings
2006", shape=ellipse, URL="RFC4648.html", target="_top", tooltip="This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. [STANDARDS-TRACK]"];
  cites -> RFC4648;
  RFC1321 [label="RFC1321
The MD5 Message-Digest Algorithm
1992", shape=ellipse, URL="RFC1321.html", target="_top", tooltip="This document describes the MD5 message-digest algorithm.  The algorithm takes as input a message of arbitrary length and produces as output a 128-bit fingerprint or message digest of the input.  This memo provides information for the Internet community.  It does not specify an Internet standard."];
  cites -> RFC1321;
  RFC3174 [label="RFC3174
US Secure Hash Algorithm 1 (SHA1)
2001", shape=ellipse, URL="RFC3174.html", target="_top", tooltip="The purpose of this document is to make the SHA-1 (Secure Hash Algorithm 1) hash algorithm conveniently available to the Internet community.  This memo provides information for the Internet community."];
  cites -> RFC3174;
  RFC1950 [label="RFC1950
ZLIB Compressed Data Format
Specification version 3.3
1996", shape=ellipse, URL="RFC1950.html", target="_top", tooltip="This specification defines a lossless compressed data format.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind."];
  cites -> RFC1950;
  RFC9260 [label="RFC9260
Stream Control Transmission Protocol
2022", shape=ellipse, URL="RFC9260.html", target="_top", tooltip="This document describes the Stream Control Transmission Protocol (SCTP) and obsoletes RFC 4960. It incorporates the specification of the chunk flags registry from RFC 6096 and the specification of the I bit of DATA chunks from RFC 7053. Therefore, RFCs 6096 and 7053 are also obsoleted by this document. In addition, RFCs 4460 and 8540, which describe errata for SCTP, are obsoleted by this document. SCTP was originally designed to transport Public Switched Telephone Network (PSTN) signaling messages over IP networks. It is also suited to be used for other applications, for example, WebRTC. SCTP is a reliable transport protocol operating on top of a connectionless packet network, such as IP. It offers the following services to its users: The design of SCTP includes appropriate congestion avoidance behavior and resistance to flooding and masquerade attacks."];
  cites -> RFC9260;
  RFC7396 [label="RFC7396
JSON Merge Patch
2014", shape=ellipse, URL="RFC7396.html", target="_top", tooltip="This specification defines the JSON merge patch format and processing rules.  The merge patch format is primarily intended for use with the HTTP PATCH method as a means of describing a set of modifications to a target resource's content."];
  cites -> RFC7396;
  RFC9457 [label="RFC9457
Problem Details for HTTP APIs
2023", shape=ellipse, URL="RFC9457.html", target="_top", tooltip="This document defines a problem detail to carry machine-readable details of errors in HTTP response content to avoid the need to define new error response formats for HTTP APIs. This document obsoletes RFC 7807."];
  cites -> RFC9457;

  rev_cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  rev_cites -> RFC9530;
  RFC9635 [label="RFC9635
Grant Negotiation and Authorization
Protocol (GNAP)
2024", shape=ellipse, URL="RFC9635.html", target="_top", tooltip="The Grant Negotiation and Authorization Protocol (GNAP) defines a mechanism for delegating authorization to a piece of software and conveying the results and artifacts of that delegation to the software.  This delegation can include access to a set of APIs as well as subject information passed directly to the software."];
  RFC9635 -> rev_cites;
  RFC9811 [label="RFC9811
Internet X.509 Public Key Infrastructure
-- HTTP Transfer for the Certificate
Management Protocol (CMP)
2025", shape=ellipse, URL="RFC9811.html", target="_top", tooltip="This document describes how to layer the Certificate Management Protocol (CMP) over HTTP. It includes the updates to RFC 6712 specified in Section 3 of RFC 9480; these updates introduce CMP URIs using a well-known prefix. It obsoletes RFC 6712; and, together with RFC 9810, it also obsoletes RFC 9480."];
  RFC9811 -> rev_cites;
}
