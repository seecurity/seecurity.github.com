digraph Flow {
  rankdir=LR;
  splines=true;
  concentrate=true;   // merge parallel edges / reduce clutter
  nodesep=0.25;       // horizontal/vertical separation between nodes
  ranksep=0.35;       // separation between ranks (columns in LR)
  RFC8610 [label="RFC8610
Concise Data Definition Language (CDDL):
A Notational Convention to Express
Concise Binary Object Representation
(CBOR) and JSON Data Structures
2019", shape=ellipse, fillcolor="#e8f0ff", tooltip="This document proposes a notational convention to express Concise Binary Object Representation (CBOR) data structures (RFC 7049).  Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON.", style=filled, fillcolor=green]; 

  obs_by [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  obs_by -> RFC8610;

  obs [label="obsoletes", shape=box, style=filled, fillcolor=lightblue];
  RFC8610 -> obs;

  updates [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  RFC8610 -> updates;

  updated_by [label="updates", shape=box, style=filled, fillcolor=lightyellow];
  updated_by -> RFC8610;
  RFC9682 [label="RFC9682
Updates to the Concise Data Definition
Language (CDDL) Grammar
2024", shape=ellipse, URL="RFC9682.html", target="_top", tooltip="The Concise Data Definition Language (CDDL), as defined in RFCs 8610 and 9165, provides an easy and unambiguous way to express structures for protocol messages and data formats that are represented in Concise Binary Object Representation (CBOR) or JSON. This document updates RFC 8610 by addressing related errata reports and making other small fixes for the ABNF grammar defined for CDDL."];
  RFC9682 -> updated_by;

  cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  RFC8610 -> cites;
  RFC7049 [label="RFC7049
Concise Binary Object Representation
(CBOR)
2013", shape=ellipse, URL="RFC7049.html", target="_top", tooltip="The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation.  These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack."];
  cites -> RFC7049;
  RFC5234 [label="RFC5234
Augmented BNF for Syntax Specifications:
ABNF
2008", shape=ellipse, URL="RFC5234.html", target="_top", tooltip="Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF.  It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications. [STANDARDS-TRACK]"];
  cites -> RFC5234;
  RFC2119 [label="RFC2119
Key words for use in RFCs to Indicate
Requirement Levels
1997", shape=ellipse, URL="RFC2119.html", target="_top", tooltip="In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements."];
  cites -> RFC2119;
  RFC8174 [label="RFC8174
Ambiguity of Uppercase vs Lowercase in
RFC 2119 Key Words
2017", shape=ellipse, URL="RFC8174.html", target="_top", tooltip="RFC 2119 specifies common key words that may be used in protocol specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the defined special meanings."];
  cites -> RFC8174;
  RFC8259 [label="RFC8259
The JavaScript Object Notation (JSON)
Data Interchange Format
2017", shape=ellipse, URL="RFC8259.html", target="_top", tooltip="JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format. It was derived from the ECMAScript Programming Language Standard. JSON defines a small set of formatting rules for the portable representation of structured data. This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance."];
  cites -> RFC8259;
  RFC4648 [label="RFC4648
The Base16, Base32, and Base64 Data
Encodings
2006", shape=ellipse, URL="RFC4648.html", target="_top", tooltip="This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. [STANDARDS-TRACK]"];
  cites -> RFC4648;
  RFC3629 [label="RFC3629
UTF-8, a transformation format of ISO
10646
2003", shape=ellipse, URL="RFC3629.html", target="_top", tooltip="ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279."];
  cites -> RFC3629;
  RFC7950 [label="RFC7950
The YANG 1.1 Data Modeling Language
2016", shape=ellipse, URL="RFC7950.html", target="_top", tooltip="YANG is a data modeling language used to model configuration data, state data, Remote Procedure Calls, and notifications for network management protocols.  This document describes the syntax and semantics of version 1.1 of the YANG language.  YANG version 1.1 is a maintenance release of the YANG language, addressing ambiguities and defects in the original specification.  There are a small number of backward incompatibilities from YANG version 1.  This document also specifies the YANG mappings to the Network Configuration Protocol (NETCONF)."];
  cites -> RFC7950;
  RFC3552 [label="RFC3552
Guidelines for Writing RFC Text on
Security Considerations
2003", shape=ellipse, URL="RFC3552.html", target="_top", tooltip="All RFCs are required to have a Security Considerations section.  Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements."];
  cites -> RFC3552;
  RFC8126 [label="RFC8126
Guidelines for Writing an IANA
Considerations Section in RFCs
2017", shape=ellipse, URL="RFC8126.html", target="_top", tooltip="Many protocols make use of points of extensibility that use constants to identify various protocol parameters. To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper. For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA). To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed. This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry. This is the third edition of this document; it obsoletes RFC 5226."];
  cites -> RFC8126;
  RFC7493 [label="RFC7493
The I-JSON Message Format
2015", shape=ellipse, URL="RFC7493.html", target="_top", tooltip="I-JSON (short for Internet JSON) is a restricted profile of JSON designed to maximize interoperability and increase confidence that software can process it successfully with predictable results."];
  cites -> RFC7493;
  RFC7071 [label="RFC7071
A Media Type for Reputation Interchange
2013", shape=ellipse, URL="RFC7071.html", target="_top", tooltip="This document defines the format of reputation response data (reputons), the media type for packaging it, and definition of a registry for the names of reputation applications and response sets."];
  cites -> RFC7071;
  RFC8007 [label="RFC8007
Content Delivery Network Interconnection
(CDNI) Control Interface / Triggers
2016", shape=ellipse, URL="RFC8007.html", target="_top", tooltip="This document describes the part of the Content Delivery Network Interconnection (CDNI) Control interface that allows a CDN to trigger activity in an interconnected CDN that is configured to deliver content on its behalf.  The upstream CDN can use this mechanism to request that the downstream CDN pre-position metadata or content or to request that it invalidate or purge metadata or content.  The upstream CDN can monitor the status of activity that it has triggered in the downstream CDN."];
  cites -> RFC8007;
  RFC8152 [label="RFC8152
CBOR Object Signing and Encryption
(COSE)
2017", shape=ellipse, URL="RFC8152.html", target="_top", tooltip="Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size.  There is a need for the ability to have basic security services defined for this data format.  This document defines the CBOR Object Signing and Encryption (COSE) protocol.  This specification describes how to create and process signatures, message authentication codes, and encryption using CBOR for serialization.  This specification additionally describes how to represent cryptographic keys using CBOR."];
  cites -> RFC8152;
  RFC8428 [label="RFC8428
Sensor Measurement Lists (SenML)
2018", shape=ellipse, URL="RFC8428.html", target="_top", tooltip="This specification defines a format for representing simple sensor measurements and device parameters in Sensor Measurement Lists (SenML).  Representations are defined in JavaScript Object Notation (JSON), Concise Binary Object Representation (CBOR), Extensible Markup Language (XML), and Efficient XML Interchange (EXI), which share the common SenML data model.  A simple sensor, such as a temperature sensor, could use one of these media types in protocols such as HTTP or the Constrained Application Protocol (CoAP) to transport the measurements of the sensor or to be configured."];
  cites -> RFC8428;

  rev_cites [label="cites", shape=box, style=filled, fillcolor=lightblue];
  rev_cites -> RFC8610;
  RFC8613 [label="RFC8613
Object Security for Constrained RESTful
Environments (OSCORE)
2019", shape=ellipse, URL="RFC8613.html", target="_top", tooltip="This document defines Object Security for Constrained RESTful Environments (OSCORE), a method for application-layer protection of the Constrained Application Protocol (CoAP), using CBOR Object Signing and Encryption (COSE). OSCORE provides end-to-end protection between endpoints communicating using CoAP or CoAP-mappable HTTP. OSCORE is designed for constrained nodes and networks supporting a range of proxy operations, including translation between different transport protocols. Although an optional functionality of CoAP, OSCORE alters CoAP options processing and IANA registration. Therefore, this document updates RFC 7252."];
  RFC8613 -> rev_cites;
  RFC8618 [label="RFC8618
Compacted-DNS (C-DNS): A Format for DNS
Packet Capture
2019", shape=ellipse, URL="RFC8618.html", target="_top", tooltip="This document describes a data representation for collections of DNS messages.  The format is designed for efficient storage and transmission of large packet captures of DNS traffic; it attempts to minimize the size of such packet capture files but retain the full DNS message contents along with the most useful transport metadata.  It is intended to assist with the development of DNS traffic- monitoring applications."];
  RFC8618 -> rev_cites;
  RFC8710 [label="RFC8710
Multipart Content-Format for the
Constrained Application Protocol (CoAP)
2020", shape=ellipse, URL="RFC8710.html", target="_top", tooltip="This memo defines application/multipart-core, an application-independent media type that can be used to combine representations of zero or more different media types (each with a Constrained Application Protocol (CoAP) Content-Format identifier) into a single representation, with minimal framing overhead."];
  RFC8710 -> rev_cites;
  RFC8727 [label="RFC8727
JSON Binding of the Incident Object
Description Exchange Format
2020", shape=ellipse, URL="RFC8727.html", target="_top", tooltip="The Incident Object Description Exchange Format (IODEF) defined in RFC 7970 provides an information model and a corresponding XML data model for exchanging incident and indicator information.  This document gives implementers and operators an alternative format to exchange the same information by defining an alternative data model implementation in JSON and its encoding in Concise Binary Object Representation (CBOR)."];
  RFC8727 -> rev_cites;
  RFC8742 [label="RFC8742
Concise Binary Object Representation
(CBOR) Sequences
2020", shape=ellipse, URL="RFC8742.html", target="_top", tooltip="This document describes the Concise Binary Object Representation (CBOR) Sequence format and associated media type application/cbor-seq. A CBOR Sequence consists of any number of encoded CBOR data items, simply concatenated in sequence. Structured syntax suffixes for media types allow other media types to build on them and make it explicit that they are built on an existing media type as their foundation. This specification defines and registers +cbor-seq as a structured syntax suffix for CBOR Sequences."];
  RFC8742 -> rev_cites;
  RFC8746 [label="RFC8746
Concise Binary Object Representation
(CBOR) Tags for Typed Arrays
2020", shape=ellipse, URL="RFC8746.html", target="_top", tooltip="The Concise Binary Object Representation (CBOR), as defined in RFC 7049, is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. This document makes use of this extensibility to define a number of CBOR tags for typed arrays of numeric data, as well as additional tags for multi-dimensional and homogeneous arrays. It is intended as the reference document for the IANA registration of the CBOR tags defined."];
  RFC8746 -> rev_cites;
  RFC8747 [label="RFC8747
Proof-of-Possession Key Semantics for
CBOR Web Tokens (CWTs)
2020", shape=ellipse, URL="RFC8747.html", target="_top", tooltip="This specification describes how to declare in a CBOR Web Token (CWT) (which is defined by RFC 8392) that the presenter of the CWT possesses a particular proof-of-possession key.  Being able to prove possession of a key is also sometimes described as being the holder-of-key.  This specification provides equivalent functionality to Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs) (RFC 7800) but using Concise Binary Object Representation (CBOR) and CWTs rather than JavaScript Object Notation (JSON) and JSON Web Tokens (JWTs)."];
  RFC8747 -> rev_cites;
  RFC8778 [label="RFC8778
Use of the HSS/LMS Hash-Based Signature
Algorithm with CBOR Object Signing and
Encryption (COSE)
2020", shape=ellipse, URL="RFC8778.html", target="_top", tooltip="This document specifies the conventions for using the Hierarchical Signature System (HSS) / Leighton-Micali Signature (LMS) hash-based signature algorithm with the CBOR Object Signing and Encryption (COSE) syntax.  The HSS/LMS algorithm is one form of hash-based digital signature; it is described in RFC 8554."];
  RFC8778 -> rev_cites;
  RFC8927 [label="RFC8927
JSON Type Definition
2020", shape=ellipse, URL="RFC8927.html", target="_top", tooltip="This document proposes a format, called JSON Type Definition (JTD), for describing the shape of JavaScript Object Notation (JSON) messages. Its main goals are to enable code generation from schemas as well as portable validation with standardized error indicators. To this end, JTD is intentionally limited to be no more expressive than the type systems of mainstream programming languages. This intentional limitation, as well as the decision to make JTD schemas be JSON documents, makes tooling atop of JTD easier to build. This document does not have IETF consensus and is presented here to facilitate experimentation with the concept of JTD."];
  RFC8927 -> rev_cites;
  RFC8949 [label="RFC8949
Concise Binary Object Representation
(CBOR)
2020", shape=ellipse, URL="RFC8949.html", target="_top", tooltip="The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack. This document obsoletes RFC 7049, providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049. It does not create a new version of the format."];
  RFC8949 -> rev_cites;
  RFC8990 [label="RFC8990
GeneRic Autonomic Signaling Protocol
(GRASP)
2021", shape=ellipse, URL="RFC8990.html", target="_top", tooltip="This document specifies the GeneRic Autonomic Signaling Protocol (GRASP), which enables autonomic nodes and Autonomic Service Agents to dynamically discover peers, to synchronize state with each other, and to negotiate parameter settings with each other.  GRASP depends on an external security environment that is described elsewhere.  The technical objectives and parameters for specific application scenarios are to be described in separate documents.  Appendices briefly discuss requirements for the protocol and existing protocols with comparable features."];
  RFC8990 -> rev_cites;
  RFC8991 [label="RFC8991
GeneRic Autonomic Signaling Protocol
Application Program Interface (GRASP
API)
2021", shape=ellipse, URL="RFC8991.html", target="_top", tooltip="This document is a conceptual outline of an Application Programming Interface (API) for the GeneRic Autonomic Signaling Protocol (GRASP).  Such an API is needed for Autonomic Service Agents (ASAs) calling the GRASP protocol module to exchange Autonomic Network messages with other ASAs.  Since GRASP is designed to support asynchronous operations, the API will need to be adapted according to the support for asynchronicity in various programming languages and operating systems."];
  RFC8991 -> rev_cites;
  RFC8992 [label="RFC8992
Autonomic IPv6 Edge Prefix Management in
Large-Scale Networks
2021", shape=ellipse, URL="RFC8992.html", target="_top", tooltip="This document defines two autonomic technical objectives for IPv6 prefix management at the edge of large-scale ISP networks, with an extension to support IPv4 prefixes.  An important purpose of this document is to use it for validation of the design of various components of the Autonomic Networking Infrastructure."];
  RFC8992 -> rev_cites;
  RFC8994 [label="RFC8994
An Autonomic Control Plane (ACP)
2021", shape=ellipse, URL="RFC8994.html", target="_top", tooltip="Autonomic functions need a control plane to communicate, which depends on some addressing and routing.  This Autonomic Control Plane should ideally be self-managing and be as independent as possible of configuration.  This document defines such a plane and calls it the Autonomic Control Plane, with the primary use as a control plane for autonomic functions.  It also serves as a virtual out-of-band channel for Operations, Administration, and Management (OAM) communications over a network that provides automatically configured, hop-by-hop authenticated and encrypted communications via automatically configured IPv6 even when the network is not configured or is misconfigured."];
  RFC8994 -> rev_cites;
  RFC8995 [label="RFC8995
Bootstrapping Remote Secure Key
Infrastructure (BRSKI)
2021", shape=ellipse, URL="RFC8995.html", target="_top", tooltip="This document specifies automated bootstrapping of an Autonomic Control Plane.  To do this, a Secure Key Infrastructure is bootstrapped.  This is done using manufacturer-installed X.509 certificates, in combination with a manufacturer's authorizing service, both online and offline.  We call this process the Bootstrapping Remote Secure Key Infrastructure (BRSKI) protocol.  Bootstrapping a new device can occur when using a routable address and a cloud service, only link-local connectivity, or limited/disconnected networks.  Support for deployment models with less stringent security requirements is included.  Bootstrapping is complete when the cryptographic identity of the new key infrastructure is successfully deployed to the device.  The established secure connection can be used to deploy a locally issued certificate to the device as well."];
  RFC8995 -> rev_cites;
  RFC9031 [label="RFC9031
Constrained Join Protocol (CoJP) for
6TiSCH
2021", shape=ellipse, URL="RFC9031.html", target="_top", tooltip="This document describes the minimal framework required for a new device, called a pledge, to securely join a 6TiSCH (IPv6 over the Time-Slotted Channel Hopping mode of IEEE 802.15.4) network.  The framework requires that the pledge and the JRC (Join Registrar/Coordinator, a central entity), share a symmetric key.  How this key is provisioned is out of scope of this document.  Through a single CoAP (Constrained Application Protocol) request-response exchange secured by OSCORE (Object Security for Constrained RESTful Environments), the pledge requests admission into the network, and the JRC configures it with link-layer keying material and other parameters.  The JRC may at any time update the parameters through another request-response exchange secured by OSCORE.  This specification defines the Constrained Join Protocol and its CBOR (Concise Binary Object Representation) data structures, and it describes how to configure the rest of the 6TiSCH communication stack for this join process to occur in a secure manner.  Additional security mechanisms may be added on top of this minimal framework."];
  RFC9031 -> rev_cites;
  RFC9052 [label="RFC9052
CBOR Object Signing and Encryption
(COSE): Structures and Process
2022", shape=ellipse, URL="RFC9052.html", target="_top", tooltip="Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. There is a need to be able to define basic security services for this data format. This document defines the CBOR Object Signing and Encryption (COSE) protocol. This specification describes how to create and process signatures, message authentication codes, and encryption using CBOR for serialization. This specification additionally describes how to represent cryptographic keys using CBOR. This document, along with RFC 9053, obsoletes RFC 8152."];
  RFC9052 -> rev_cites;
  RFC9053 [label="RFC9053
CBOR Object Signing and Encryption
(COSE): Initial Algorithms
2022", shape=ellipse, URL="RFC9053.html", target="_top", tooltip="Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. There is a need to be able to define basic security services for this data format. This document defines a set of algorithms that can be used with the CBOR Object Signing and Encryption (COSE) protocol (RFC 9052). This document, along with RFC 9052, obsoletes RFC 8152."];
  RFC9053 -> rev_cites;
  RFC9090 [label="RFC9090
Concise Binary Object Representation
(CBOR) Tags for Object Identifiers
2021", shape=ellipse, URL="RFC9090.html", target="_top", tooltip="The Concise Binary Object Representation (CBOR), defined in RFC 8949, is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. This document defines CBOR tags for object identifiers (OIDs) and is the reference document for the IANA registration of the CBOR tags so defined."];
  RFC9090 -> rev_cites;
  RFC9115 [label="RFC9115
An Automatic Certificate Management
Environment (ACME) Profile for
Generating Delegated Certificates
2021", shape=ellipse, URL="RFC9115.html", target="_top", tooltip="This document defines a profile of the Automatic Certificate Management Environment (ACME) protocol by which the holder of an identifier (e.g., a domain name) can allow a third party to obtain an X.509 certificate such that the certificate subject is the delegated identifier while the certified public key corresponds to a private key controlled by the third party.  A primary use case is that of a Content Delivery Network (CDN), the third party, terminating TLS sessions on behalf of a content provider (the holder of a domain name).  The presented mechanism allows the holder of the identifier to retain control over the delegation and revoke it at any time.  Importantly, this mechanism does not require any modification to the deployed TLS clients and servers."];
  RFC9115 -> rev_cites;
  RFC9164 [label="RFC9164
Concise Binary Object Representation
(CBOR) Tags for IPv4 and IPv6 Addresses
and Prefixes
2021", shape=ellipse, URL="RFC9164.html", target="_top", tooltip="This specification defines two Concise Binary Object Representation (CBOR) tags for use with IPv6 and IPv4 addresses and prefixes."];
  RFC9164 -> rev_cites;
  RFC9165 [label="RFC9165
Additional Control Operators for the
Concise Data Definition Language (CDDL)
2021", shape=ellipse, URL="RFC9165.html", target="_top", tooltip="The Concise Data Definition Language (CDDL), standardized in RFC 8610, provides control operators as its main language extension point. The present document defines a number of control operators that were not yet ready at the time RFC 8610 was completed: .plus, .cat, and .det for the construction of constants; .abnf/.abnfb for including ABNF (RFC 5234 and RFC 7405) in CDDL specifications; and .feature for indicating the use of a non-basic feature in an instance."];
  RFC9165 -> rev_cites;
  RFC9177 [label="RFC9177
Constrained Application Protocol (CoAP)
Block-Wise Transfer Options Supporting
Robust Transmission
2022", shape=ellipse, URL="RFC9177.html", target="_top", tooltip="This document specifies alternative Constrained Application Protocol (CoAP) block-wise transfer options: Q-Block1 and Q-Block2. These options are similar to, but distinct from, the CoAP Block1 and Block2 options defined in RFC 7959. The Q-Block1 and Q-Block2 options are not intended to replace the Block1 and Block2 options but rather have the goal of supporting Non-confirmable (NON) messages for large amounts of data with fewer packet interchanges. Also, the Q-Block1 and Q-Block2 options support faster recovery should any of the blocks get lost in transmission."];
  RFC9177 -> rev_cites;
  RFC9200 [label="RFC9200
Authentication and Authorization for
Constrained Environments Using the OAuth
2.0 Framework (ACE-OAuth)
2022", shape=ellipse, URL="RFC9200.html", target="_top", tooltip="This specification defines a framework for authentication and authorization in Internet of Things (IoT) environments called ACE-OAuth.  The framework is based on a set of building blocks including OAuth 2.0 and the Constrained Application Protocol (CoAP), thus transforming a well-known and widely used authorization solution into a form suitable for IoT devices.  Existing specifications are used where possible, but extensions are added and profiles are defined to better serve the IoT use cases."];
  RFC9200 -> rev_cites;
  RFC9202 [label="RFC9202
Datagram Transport Layer Security (DTLS)
Profile for Authentication and
Authorization for Constrained
Environments (ACE)
2022", shape=ellipse, URL="RFC9202.html", target="_top", tooltip="This specification defines a profile of the Authentication and Authorization for Constrained Environments (ACE) framework that allows constrained servers to delegate client authentication and authorization.  The protocol relies on DTLS version 1.2 or later for communication security between entities in a constrained network using either raw public keys or pre-shared keys.  A resource-constrained server can use this protocol to delegate management of authorization information to a trusted host with less-severe limitations regarding processing power and memory."];
  RFC9202 -> rev_cites;
  RFC9203 [label="RFC9203
The Object Security for Constrained
RESTful Environments (OSCORE) Profile of
the Authentication and Authorization for
Constrained Environments (ACE) Framework
2022", shape=ellipse, URL="RFC9203.html", target="_top", tooltip="This document specifies a profile for the Authentication and Authorization for Constrained Environments (ACE) framework.  It utilizes Object Security for Constrained RESTful Environments (OSCORE) to provide communication security and proof-of-possession for a key owned by the client and bound to an OAuth 2.0 access token."];
  RFC9203 -> rev_cites;
  RFC9237 [label="RFC9237
An Authorization Information Format
(AIF) for Authentication and
Authorization for Constrained
Environments (ACE)
2022", shape=ellipse, URL="RFC9237.html", target="_top", tooltip="Information about which entities are authorized to perform what operations on which constituents of other entities is a crucial component of producing an overall system that is secure. Conveying precise authorization information is especially critical in highly automated systems with large numbers of entities, such as the Internet of Things. This specification provides a generic information model and format for representing such authorization information, as well as two variants of a specific instantiation of that format for use with Representational State Transfer (REST) resources identified by URI path."];
  RFC9237 -> rev_cites;
  RFC9254 [label="RFC9254
Encoding of Data Modeled with YANG in
the Concise Binary Object Representation
(CBOR)
2022", shape=ellipse, URL="RFC9254.html", target="_top", tooltip="YANG (RFC 7950) is a data modeling language used to model configuration data, state data, parameters and results of Remote Procedure Call (RPC) operations or actions, and notifications. This document defines encoding rules for YANG in the Concise Binary Object Representation (CBOR) (RFC 8949)."];
  RFC9254 -> rev_cites;
  RFC9277 [label="RFC9277
On Stable Storage for Items in Concise
Binary Object Representation (CBOR)
2022", shape=ellipse, URL="RFC9277.html", target="_top", tooltip="This document defines a stored (file) format for Concise Binary Object Representation (CBOR) data items that is friendly to common systems that recognize file types, such as the Unix file(1) command."];
  RFC9277 -> rev_cites;
  RFC9290 [label="RFC9290
Concise Problem Details for Constrained
Application Protocol (CoAP) APIs
2022", shape=ellipse, URL="RFC9290.html", target="_top", tooltip="This document defines a concise problem detail as a way to carry machine-readable details of errors in a Representational State Transfer (REST) response to avoid the need to define new error response formats for REST APIs for constrained environments.  The format is inspired by, but intended to be more concise than, the problem details for HTTP APIs defined in RFC 7807."];
  RFC9290 -> rev_cites;
  RFC9321 [label="RFC9321
Signature Validation Token
2022", shape=ellipse, URL="RFC9321.html", target="_top", tooltip="Electronic signatures have a limited lifespan with respect to the time period that they can be validated and determined to be authentic.  The Signature Validation Token (SVT) defined in this specification provides evidence that asserts the validity of an electronic signature.  The SVT is provided by a trusted authority, which asserts that a particular signature was successfully validated according to defined procedures at a certain time.  Any future validation of that electronic signature can be satisfied by validating the SVT without any need to also validate the original electronic signature or the associated digital certificates.  The SVT supports electronic signatures in Cryptographic Message Syntax (CMS), XML, PDF, and JSON documents."];
  RFC9321 -> rev_cites;
  RFC9338 [label="RFC9338
CBOR Object Signing and Encryption
(COSE): Countersignatures
2022", shape=ellipse, URL="RFC9338.html", target="_top", tooltip="Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size.  CBOR Object Signing and Encryption (COSE) defines a set of security services for CBOR.  This document defines a countersignature algorithm along with the needed header parameters and CBOR tags for COSE.  This document updates RFC 9052."];
  RFC9338 -> rev_cites;
  RFC9360 [label="RFC9360
CBOR Object Signing and Encryption
(COSE): Header Parameters for Carrying
and Referencing X.509 Certificates
2023", shape=ellipse, URL="RFC9360.html", target="_top", tooltip="The CBOR Object Signing and Encryption (COSE) message structure uses references to keys in general.  For some algorithms, additional properties are defined that carry parameters relating to keys as needed.  The COSE Key structure is used for transporting keys outside of COSE messages.  This document extends the way that keys can be identified and transported by providing attributes that refer to or contain X.509 certificates."];
  RFC9360 -> rev_cites;
  RFC9393 [label="RFC9393
Concise Software Identification Tags
2023", shape=ellipse, URL="RFC9393.html", target="_top", tooltip="ISO/IEC 19770-2:2015 Software Identification (SWID) tags provide an extensible XML-based structure to identify and describe individual software components, patches, and installation bundles.  SWID tag representations can be too large for devices with network and storage constraints.  This document defines a concise representation of SWID tags: Concise SWID (CoSWID) tags.  CoSWID supports a set of semantics and features that are similar to those for SWID tags, as well as new semantics that allow CoSWIDs to describe additional types of information, all in a more memory-efficient format."];
  RFC9393 -> rev_cites;
  RFC9431 [label="RFC9431
Message Queuing Telemetry Transport
(MQTT) and Transport Layer Security
(TLS) Profile of Authentication and
Authorization for Constrained
Environments (ACE) Framework
2023", shape=ellipse, URL="RFC9431.html", target="_top", tooltip="This document specifies a profile for the Authentication and Authorization for Constrained Environments (ACE) framework to enable authorization in a publish-subscribe messaging system based on Message Queuing Telemetry Transport (MQTT).  Proof-of-Possession keys, bound to OAuth 2.0 access tokens, are used to authenticate and authorize MQTT Clients.  The protocol relies on TLS for confidentiality and MQTT server (Broker) authentication."];
  RFC9431 -> rev_cites;
  RFC9526 [label="RFC9526
Simple Provisioning of Public Names for
Residential Networks
2024", shape=ellipse, URL="RFC9526.html", target="_top", tooltip="Home network owners may have devices or services hosted on their home network that they wish to access from the Internet (i.e., from a network outside of the home network). Home networks are increasingly numbered using IPv6 addresses, which in principle makes this access simpler, but accessing home networks from the Internet requires the names and IP addresses of these devices and services to be made available in the public DNS. This document describes how a Home Naming Authority (NHA) instructs the outsourced infrastructure to publish these pieces of information in the public DNS. The names and IP addresses of the home network are set in the Public Homenet Zone by the Homenet Naming Authority (HNA), which in turn instructs an outsourced infrastructure to publish the zone on behalf of the home network owner."];
  RFC9526 -> rev_cites;
  RFC9528 [label="RFC9528
Ephemeral Diffie-Hellman Over COSE
(EDHOC)
2024", shape=ellipse, URL="RFC9528.html", target="_top", tooltip="This document specifies Ephemeral Diffie-Hellman Over COSE (EDHOC), a very compact and lightweight authenticated Diffie-Hellman key exchange with ephemeral keys.  EDHOC provides mutual authentication, forward secrecy, and identity protection.  EDHOC is intended for usage in constrained scenarios, and a main use case is to establish an Object Security for Constrained RESTful Environments (OSCORE) security context.  By reusing CBOR Object Signing and Encryption (COSE) for cryptography, Concise Binary Object Representation (CBOR) for encoding, and Constrained Application Protocol (CoAP) for transport, the additional code size can be kept very low."];
  RFC9528 -> rev_cites;
  RFC9581 [label="RFC9581
Concise Binary Object Representation
(CBOR) Tags for Time, Duration, and
Period
2024", shape=ellipse, URL="RFC9581.html", target="_top", tooltip="The Concise Binary Object Representation (CBOR, RFC 8949) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. In CBOR, one point of extensibility is the definition of CBOR tags. RFC 8949 defines two tags for time: CBOR tag 0 (RFC 3339 time as a string) and tag 1 (POSIX time as int or float). Since then, additional requirements have become known. The present document defines a CBOR tag for time that allows a more elaborate representation of time, as well as related CBOR tags for duration and time period. This document is intended as the reference document for the IANA registration of the CBOR tags defined."];
  RFC9581 -> rev_cites;
  RFC9594 [label="RFC9594
Key Provisioning for Group Communication
Using Authentication and Authorization
for Constrained Environments (ACE)
2024", shape=ellipse, URL="RFC9594.html", target="_top", tooltip="This document defines how to use the Authentication and Authorization for Constrained Environments (ACE) framework to distribute keying material and configuration parameters for secure group communication.  Candidate group members that act as Clients and are authorized to join a group can do so by interacting with a Key Distribution Center (KDC) acting as the Resource Server, from which they obtain the keying material to communicate with other group members.  While defining general message formats as well as the interface and operations available at the KDC, this document supports different approaches and protocols for secure group communication.  Therefore, details are delegated to separate application profiles of this document as specialized instances that target a particular group communication approach and define how communications in the group are protected.  Compliance requirements for such application profiles are also specified."];
  RFC9594 -> rev_cites;
  RFC9597 [label="RFC9597
CBOR Web Token (CWT) Claims in COSE
Headers
2024", shape=ellipse, URL="RFC9597.html", target="_top", tooltip="This document describes how to include CBOR Web Token (CWT) claims in the header parameters of any CBOR Object Signing and Encryption (COSE) structure.  This functionality helps to facilitate applications that wish to make use of CWT claims in encrypted COSE structures and/or COSE structures featuring detached signatures, while having some of those claims be available before decryption and/or without inspecting the detached payload.  Another use case is using CWT claims with payloads that are not CWT Claims Sets, including payloads that are not CBOR at all."];
  RFC9597 -> rev_cites;
  RFC9682 [label="RFC9682
Updates to the Concise Data Definition
Language (CDDL) Grammar
2024", shape=ellipse, URL="RFC9682.html", target="_top", tooltip="The Concise Data Definition Language (CDDL), as defined in RFCs 8610 and 9165, provides an easy and unambiguous way to express structures for protocol messages and data formats that are represented in Concise Binary Object Representation (CBOR) or JSON. This document updates RFC 8610 by addressing related errata reports and making other small fixes for the ABNF grammar defined for CDDL."];
  RFC9682 -> rev_cites;
  RFC9711 [label="RFC9711
The Entity Attestation Token (EAT)
2025", shape=ellipse, URL="RFC9711.html", target="_top", tooltip="An Entity Attestation Token (EAT) provides an attested claims set that describes the state and characteristics of an entity, a device such as a smartphone, an Internet of Things (IoT) device, network equipment, or such. This claims set is used by a relying party, server, or service to determine the type and degree of trust placed in the entity. An EAT is either a CBOR Web Token (CWT) or a JSON Web Token (JWT) with attestation-oriented claims."];
  RFC9711 -> rev_cites;
  RFC9741 [label="RFC9741
Concise Data Definition Language (CDDL):
Additional Control Operators for the
Conversion and Processing of Text
2025", shape=ellipse, URL="RFC9741.html", target="_top", tooltip="The Concise Data Definition Language (CDDL), standardized in RFC 8610, provides control operators as its main language extension point. RFCs have added to this extension point in both an application-specific and a more general way. The present document defines a number of additional generally applicable control operators for text conversion (bytes, integers, printf-style formatting, and JSON) and for an operation on text."];
  RFC9741 -> rev_cites;
  RFC9758 [label="RFC9758
Updates to the 'ipn' URI Scheme
2025", shape=ellipse, URL="RFC9758.html", target="_top", tooltip="This document updates the specification of the 'ipn' URI scheme previously defined in RFC 6260 and the IANA registries established in RFC 7116.  It also updates the rules for the encoding and decoding of these URIs when used as an Endpoint Identifier (EID) in the Bundle Protocol version 7 (BPv7) as defined in RFC 9171.  These updates clarify the structure and behavior of the 'ipn' URI scheme, define new encodings of 'ipn' scheme URIs, and establish the registries necessary to manage this scheme."];
  RFC9758 -> rev_cites;
  RFC9770 [label="RFC9770
Notification of Revoked Access Tokens in
the Authentication and Authorization for
Constrained Environments (ACE) Framework
2025", shape=ellipse, URL="RFC9770.html", target="_top", tooltip="This document specifies a method of the Authentication and Authorization for Constrained Environments (ACE) framework, which allows an authorization server to notify clients and resource servers (i.e., registered devices) about revoked access tokens.  As specified in this document, the method allows clients and resource servers (RSs) to access a Token Revocation List (TRL) on the authorization server by using the Constrained Application Protocol (CoAP), with the possible additional use of resource observation.  Resulting (unsolicited) notifications of revoked access tokens complement alternative approaches such as token introspection, while not requiring additional endpoints on clients and RSs."];
  RFC9770 -> rev_cites;
  RFC9781 [label="RFC9781
A Concise Binary Object Representation
(CBOR) Tag for Unprotected CBOR Web
Token Claims Sets (UCCS)
2025", shape=ellipse, URL="RFC9781.html", target="_top", tooltip="This document defines the Unprotected CWT Claims Set (UCCS), a data format for representing a CBOR Web Token (CWT) Claims Set without protecting it by a signature, Message Authentication Code (MAC), or encryption.  UCCS enables the use of CWT claims in environments where protection is provided by other means, such as secure communication channels or trusted execution environments.  This specification defines a CBOR tag for UCCS and describes the UCCS format, its encoding, and its processing considerations.  It also discusses security implications of using unprotected claims sets."];
  RFC9781 -> rev_cites;
  RFC9783 [label="RFC9783
Arm's Platform Security Architecture
(PSA) Attestation Token
2025", shape=ellipse, URL="RFC9783.html", target="_top", tooltip="Arm's Platform Security Architecture (PSA) is a family of hardware and firmware security specifications, along with open-source reference implementations, aimed at helping device makers and chip manufacturers integrate best-practice security into their products. Devices that comply with PSA can generate attestation tokens as described in this document, which serve as the foundation for various protocols, including secure provisioning and network access control. This document specifies the structure and semantics of the PSA attestation token. The PSA attestation token is a profile of the Entity Attestation Token (EAT). This specification describes the claims used in an attestation token generated by PSA-compliant systems, how these claims are serialized for transmission, and how they are cryptographically protected. This Informational document is published as an Independent Submission to improve interoperability with Arm's architecture. It is not a standard nor a product of the IETF."];
  RFC9783 -> rev_cites;
  RFC9886 [label="RFC9886
DRIP Entity Tags (DETs) in the Domain
Name System
2025", shape=ellipse, URL="RFC9886.html", target="_top", tooltip="This document defines the Domain Name System (DNS) functionality of a Drone Remote Identification Protocol (DRIP) Identity Management Entity (DIME).  It is built around DRIP Entity Tags (DETs) to standardize a hierarchical registry structure and associated processes to facilitate trustable and scalable registration and lookup of information related to Unmanned Aircraft Systems (UAS).  The registry system supports issuance, discovery, and verification of DETs, enabling secure identification and association of UAS and their operators.  It also defines the interactions between different classes of registries (root, organizational, and individual) and their respective roles in maintaining the integrity of the registration data.  This architecture enables decentralized, federated operation while supporting privacy, traceability, and regulatory compliance requirements in the context of UAS Remote Identification and other services."];
  RFC9886 -> rev_cites;
  RFC9891 [label="RFC9891
Automated Certificate Management
Environment (ACME) Delay-Tolerant
Networking (DTN) Node ID Validation
Extension
2025", shape=ellipse, URL="RFC9891.html", target="_top", tooltip="This document specifies an extension to the Automated Certificate Management Environment (ACME) protocol that allows an ACME server to validate the Delay-Tolerant Networking (DTN) Node ID for an ACME client.  A DTN Node ID is an identifier used in the Bundle Protocol (BP) to name a singleton endpoint: an endpoint that is registered on a single BP Node.  The DTN Node ID is encoded both as a certificate Subject Alternative Name (SAN) identity of type otherName with an Other Name form of BundleEID and as an ACME Identifier type bundleEID."];
  RFC9891 -> rev_cites;
}
